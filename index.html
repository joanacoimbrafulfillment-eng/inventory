<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory Management System v50</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; background-color: #f4f7f9; margin: 20px; color: #333; }
        .container { max-width: 1800px; margin: auto; background: white; padding: 30px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
        
        .header-flex { display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; background: #2c3e50; color: white; padding: 20px; border-radius: 12px; }
        .month-selector { background: #34495e; color: white; border: 1px solid #7f8c8d; padding: 10px; border-radius: 8px; font-weight: bold; cursor: pointer; }
        
        .tabs { display: flex; gap: 5px; margin-bottom: 25px; border-bottom: 2px solid #eee; padding-bottom: 12px; overflow-x: auto; }
        .tab-btn { padding: 10px 15px; cursor: pointer; border: none; background: #e4e6eb; border-radius: 8px; font-weight: bold; color: #4b4b4b; white-space: nowrap; font-size: 0.85em; transition: 0.3s; }
        .tab-btn.active { background: #007bff; color: white; transform: translateY(-2px); }

        .tab-content { display: none; }
        .tab-content.active { display: block; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        table { width: 100%; border-collapse: collapse; margin-top: 10px; background: white; font-size: 0.82em; }
        th, td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #eee; }
        th { background-color: #f8f9fa; color: #333; text-transform: uppercase; position: sticky; top: 0; z-index: 5; }
        
        .section-box { border: 1px solid #eee; padding: 15px; border-radius: 12px; margin-bottom: 20px; background: #fff; }
        .entry-row { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; align-items: flex-end; }
        .input-single { padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.9em; }

        .split-layout { display: flex; gap: 20px; align-items: flex-start; }
        .split-side-left { flex: 0 0 45%; min-width: 0; }
        .split-side-right { flex: 0 0 55%; min-width: 0; }

        .bulk-area { width: 100%; height: 300px; padding: 15px; border: 1px solid #ccc; border-radius: 8px; font-family: monospace; box-sizing: border-box; background: #fafafa; font-size: 1em; }
        
        .btn { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 0.85em; transition: 0.2s; }
        .btn-primary { background: #007bff; color: white; }
        .btn-warning { background: #f39c12; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-excel { background: #1d6f42; color: white; }
        .btn-danger { background: #e74c3c; color: white; }
        
        .stock-val { font-weight: bold; }
        .real-col { color: #000 !important; font-weight: bold; } 
        .amsped-col { color: #000 !important; font-weight: bold; }
        .transit-val { color: #000 !important; font-weight: bold; }
        .confirm-col { color: #000 !important; font-weight: bold; }
        .order-col { color: #000 !important; font-weight: bold; }

        /* Highlight for urgent orders */
        .urgent-row { background-color: #fff2f2 !important; border-left: 4px solid #ff7675; }

        .badge { padding: 4px 8px; border-radius: 4px; font-weight: bold; font-size: 0.8em; }
        .bg-order { background: #d1d8e0; color: #4b6584; }
        .bg-sent { background: #fed330; color: #856404; }
        .bg-received { background: #26de81; color: #ffffff; }

        #initView { position: absolute; top: 120px; left: 0; width: 100%; height: 80%; background: white; z-index: 1000; display: flex; justify-content: center; align-items: center; }
        .init-card { text-align: center; padding: 60px; border: 3px dashed #dcdde1; border-radius: 20px; background: #f9f9f9; }

        .modal { display:none; position:fixed; z-index:100; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.5); }
        .modal-content { background:#fff; margin:5% auto; padding:20px; width:75%; border-radius:10px; max-height:80vh; overflow-y:auto; }
    
        /* v50: quantity color bars + legend */
        .qty-wrap { display:flex; flex-direction:column; gap:4px; }
        .qty-num { font-weight:700; font-size:1.25em; color:#000; line-height:1; }
        .qty-bar { height:4px; border-radius:4px; background:#e0e0e0; }
        .qty-neg { background:#ff1744; }          /* < 0 vivid red */
        .qty-low { background:#ff8a80; }          /* 0-10 light red */
        .qty-mid { background:#fff59d; }          /* 11-199 light yellow */
        .qty-good { background:#b9f6ca; }         /* 200-500 light green */
        .qty-high { background:#81d4fa; }         /* 501-1000+ light blue */
        .legend { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:10px 0 18px; }
        .legend-item { display:flex; align-items:center; gap:8px; font-size:12px; color:#444; background:#fafafa; border:1px solid #eee; padding:5px 9px; border-radius:999px; }
        .legend-swatch { width:12px; height:8px; border-radius:4px; border:1px solid rgba(0,0,0,.08); }

    </style>
</head>
<body>

<div class="container">
    <div class="header-flex">
        <h2 style="margin:0">Inventory System v44</h2>
        <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
            <div><input type="month" id="monthPicker" class="month-selector" onchange="changeMonth()"></div>

            <!-- Auth -->
            <div id="authPanel" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                <span id="authUser" style="font-size:0.9em; opacity:.95;"></span>
                <input id="loginEmail" class="input-single" style="width:220px" placeholder="email@empresa.pt / .pl">
                <input id="loginPass" class="input-single" style="width:150px" type="password" placeholder="password">
                <button id="loginBtn" class="btn btn-success" onclick="doLogin()">Login</button>
                <button id="logoutBtn" class="btn btn-danger" style="display:none" onclick="doLogout()">Logout</button>
            </div>
        </div>
    </div>

    <div id="fileProtoWarn" class="section-box" style="display:none; border-left:5px solid #e74c3c;">
        <b>‚ö†Ô∏è Firebase Auth n√£o funciona em <code>file://</code></b><br>
        Abre este ficheiro via <b>http://localhost</b> (ex.: <code>python -m http.server 8000</code>) ou publica em Firebase Hosting.
    </div>

    <div id="initView" style="display:none">
        <div class="init-card">
            <h2 id="initTitle">Period not initialized</h2>
            <button class="btn btn-primary" onclick="initializeMonth(true)">üöÄ CARRY OVER PREVIOUS STOCK</button>
            <br><br>
            <button class="btn btn-warning" onclick="initializeMonth(false)">üìÅ START FROM ZERO</button>
        </div>
    </div>

    <div id="mainInterface">
        <div class="tabs">
            <div class="tab-btn active" onclick="openTab('general')">üìã General</div>
            <div class="tab-btn" onclick="openTab('analytics')">üìä Analytics</div>
            <div class="tab-btn" onclick="openTab('shipments')">üì¶ Orders & Shipments</div>
            <div class="tab-btn" onclick="openTab('adjustments')">üîß Adjustments</div>
            <div class="tab-btn" onclick="openTab('returns')">üîÑ Returns & Recovered</div>
            <div class="tab-btn" onclick="openTab('internal')">üè¢ Internal & Care</div>
            <div class="tab-btn" onclick="openTab('picking')">üì¶ Picking Out</div>
            <div class="tab-btn" onclick="openTab('amsped')">üõí Amsped Sales</div>
            <div class="tab-btn" onclick="openTab('b2b')">ü§ù B2B</div>
            <div class="tab-btn" onclick="openTab('movements')">üßæ Movements</div>
            <div class="tab-btn" onclick="openTab('warehouse')">üè∑Ô∏è Warehouse</div>
            <div class="tab-btn" onclick="openTab('management')">‚öôÔ∏è Management</div>
        </div>

        <datalist id="productList"></datalist>

        <!-- 1. GENERAL -->
        <div id="general" class="tab-content active">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <div id="generalUpdatedAt" style="font-size:12px; color:#666;"></div>
                <button class="btn btn-secondary" style="padding:6px 10px; font-size:12px;" onclick="reconnectGeneral()">üîÑ Reconnect</button>
                <button id="btnBackfillGeneral" class="btn btn-success" style="padding:6px 10px; font-size:12px; margin-left:8px; display:none;" onclick="backfillGeneralViews()">üì£ Publicar meses p/ PL</button>
            </div>
            <div id="dash-general" class="dashboard-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 20px;"></div>

            <div class="legend" id="qtyLegend">
                <div class="legend-item"><span class="legend-swatch qty-neg"></span><span>&lt; 0</span></div>
                <div class="legend-item"><span class="legend-swatch qty-low"></span><span>0‚Äì10</span></div>
                <div class="legend-item"><span class="legend-swatch qty-mid"></span><span>11‚Äì199</span></div>
                <div class="legend-item"><span class="legend-swatch qty-good"></span><span>200‚Äì500</span></div>
                <div class="legend-item"><span class="legend-swatch qty-high"></span><span>501‚Äì1000+</span></div>
            </div>

            <input type="text" id="search" class="search-box" style="width:100%; padding:12px; margin-bottom:15px; border-radius:8px; border:1px solid #ddd;" placeholder="Search SKU or Name..." onkeyup="filterTable('bodyGeneral', 'search')">
            <table>
                <thead>
                    <tr><th>Products (Sorted)</th><th>Real Stock</th><th>Stock after Amsped</th><th>SENT (Transit)</th></tr>
                </thead>
                <tbody id="bodyGeneral"></tbody>
            </table>
        </div>

        <!-- 2. ANALYTICS -->
        <div id="analytics" class="tab-content">
            <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:end; margin-bottom:10px;">
                <div>
                    <label style="font-size:12px;color:#666;">Per√≠odo</label><br>
                    <select id="analyticsMode" class="input-single" onchange="renderAnalytics()">
                        <option value="month">M√™s</option>
                        <option value="year">Ano</option>
                        <option value="all">Tudo</option>
                    </select>
                </div>

                <div id="analyticsMonthWrap">
                    <label style="font-size:12px;color:#666;">M√™s (Analytics)</label><br>
                    <select id="analyticsMonth" class="input-single" onchange="renderAnalytics()"></select>
                </div>

                <div id="analyticsYearWrap">
                    <label style="font-size:12px;color:#666;">Ano</label><br>
                    <select id="analyticsYear" class="input-single" onchange="renderAnalytics()"></select>
                </div>

                <div style="margin-left:auto; display:flex; gap:10px;">
                    <button class="btn btn-excel" onclick="exportAnalyticsCSV()">‚¨áÔ∏è Export Analytics (CSV)</button>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                <div style="grid-column: span 2; height: 350px; border: 1px solid #eee; padding: 15px; border-radius: 12px;"><h3>Daily Picking Activity</h3><canvas id="dailyChart"></canvas></div>
                <div style="height: 300px; border: 1px solid #eee; padding: 15px; border-radius: 12px;"><h3>Top Sold</h3><canvas id="topSoldChart"></canvas></div>
                <div style="height: 300px; border: 1px solid #eee; padding: 15px; border-radius: 12px;"><h3>Returns</h3><canvas id="returnsChart"></canvas></div>
                <div class="section-box" style="grid-column: span 2;">
                    <h3>üì¶ Procurement Coverage (ORDER vs SENT vs RECEIVED)</h3>
                    <p style="margin-top:-6px;color:#666;font-size:12px;">Ordenado por: <b>Ordered - (Sent + Received)</b>. Mostra apenas SKUs com valor &gt; 0.</p>
                    <table id="disTable">
                        <thead>
                            <tr>
                                <th>SKU</th>
                                <th>Ordered</th>
                                <th>Sent</th>
                                <th>Received</th>
                                <th style="color:red">Ordered - (Sent+Received)</th>
                            </tr>
                        </thead>
                        <tbody id="bodyDiscrepancies"></tbody>
                    </table>
                </div>
                </div>
            </div>
        </div>

        <!-- 3. ORDERS & SHIPMENTS (PRIORITY SORTING v44) -->
        <div id="shipments" class="tab-content">
            <div class="split-layout">
                <!-- Left: Support Table Sorted by Procurement Priority -->
                <div class="split-side-left">
                    <div class="section-box">
                        <h3>üìä Procurement Priority Analysis</h3>
                        <p style="font-size:0.75em; color:gray; margin-bottom:10px;">üî¥ Rows highlighted in pink: (Real + SENT) < TO CONFIRM. Needs immediate ordering.</p>
                        <input type="text" id="searchOrds" class="search-box" style="width:100%; padding:8px;" placeholder="Filter..." onkeyup="filterTable('bodyOrderInventory', 'searchOrds')">
                        <div style="max-height: 750px; overflow-y: auto;">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Product</th>
                                        <th>Real</th>
                                        <th>Amsped</th>
                                        <th>SENT</th>
                                        <th>TO CONFIRM</th>
                                        <th>ORDER</th>
                                    </tr>
                                </thead>
                                <tbody id="bodyOrderInventory"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <!-- Right: Inputs & History -->
                <div class="split-side-right">
                    <div class="section-box" style="border-left: 5px solid #8e44ad; background: #fafafa;">
                        <h3>üîÑ 1. Update TO CONFIRM (Overwrite)</h3>
                        <div class="entry-row">
                            <input type="text" list="productList" id="confSku" class="input-single" style="width:180px" placeholder="SKU">
                            <input type="number" id="confQty" class="input-single" style="width:70px" placeholder="New Qty">
                            <button class="btn btn-info" onclick="updateToConfirm('single')">Update SKU</button>
                        </div>
                        <textarea id="inputToConfirm" class="bulk-area" style="height:100px" placeholder="Bulk: SKU QTY"></textarea>
                        <div style="display: flex; justify-content: space-between;">
                            <button class="btn btn-info" onclick="updateToConfirm('bulk')">Overwrite Bulk</button>
                            <button class="btn btn-danger" onclick="clearToConfirm()">‚ùå CLEAR ALL TO CONFIRM</button>
                        </div>
                    </div>

                    <div class="section-box">
                        <h3>üìù 2. Register Order (Intent)</h3>
                        <div class="entry-row">
                            <input type="date" id="ordDate" class="input-single today-date">
                            <input type="text" list="productList" id="ordSku" class="input-single" style="width:180px" placeholder="SKU">
                            <input type="number" id="ordQty" class="input-single" style="width:70px" placeholder="Qty">
                            <button class="btn btn-primary" onclick="addOrderLog('ORDER')">Save Order</button>
                        </div>
                        <textarea id="inputOrdBulk" class="bulk-area" style="height:90px" placeholder="Bulk: Produto QTY"></textarea>
                        <button class="btn btn-primary" onclick="processBulkOrderLog('ORDER')">Bulk Process</button>
                    </div>

                    <div class="section-box">
                        <h3>üö¢ 3. Register Shipment (SENT)</h3>
                        <div class="entry-row">
                            <input type="date" id="shipDate" class="input-single today-date">
                            <input type="text" list="productList" id="shipSku" class="input-single" style="width:180px" placeholder="SKU">
                            <input type="number" id="shipQty" class="input-single" style="width:70px" placeholder="Qty">
                            <input type="text" id="shipNote" class="input-single" style="width:220px" placeholder="Obs (opcional)">
                            <button class="btn btn-warning" onclick="addOrderLog('SENT')">Register SENT</button>
                        </div>
                        <textarea id="inputShipBulk" class="bulk-area" style="height:90px" placeholder="Bulk: Produto QTY"></textarea>
                        <button class="btn btn-warning" onclick="processBulkOrderLog('SENT')">Bulk Process</button>
                    </div>

                    <div class="section-box">
                        <h3>üìã Workflow History</h3>
                        <table>
                            <thead><tr><th>Date</th><th>Product</th><th>Status</th><th>Qty</th><th>Arrival</th><th>Obs</th><th>Actions</th></tr></thead>
                            <tbody id="bodyShipments"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- 4. ADJUSTMENTS -->
        <div id="adjustments" class="tab-content"><div class="section-box"><h3>üîß Global Adjustments</h3><div class="entry-row"><input type="date" id="dateAdjust" class="input-single today-date"><input type="text" list="productList" id="singleAdjustSku" class="input-single" style="width:200px" placeholder="SKU"><input type="number" id="singleAdjustQty" class="input-single" style="width:70px" placeholder="Qty"><input type="text" id="singleAdjustNote" class="input-single" placeholder="Reason"><button class="btn btn-warning" onclick="addSingle('adjust')">Apply</button></div><textarea id="inputAdjust" class="bulk-area" placeholder="Bulk: SKU QTY"></textarea><button class="btn btn-warning" onclick="processBulk('adjust')">Process Bulk</button><div class="recent-entries-box"><h4>üïí Recent Adjustments</h4><table id="recent-adjust"></table></div></div></div>

        <!-- OPERATIVE TABS (Returns, Internal, Picking, Amsped) -->
        <div id="returns" class="tab-content"><div class="section-box"><h3>üîÑ Returns</h3><div class="entry-row"><select id="typeReturns" class="input-single"><option value="returns">Return</option><option value="refunds">Refund</option><option value="recovered">Recovered</option></select><input type="date" id="dateReturns" class="input-single today-date"><input type="text" list="productList" id="singleReturnsSku" class="input-single" style="width:250px"><input type="number" id="singleReturnsQty" class="input-single" style="width:70px" value="1"><button class="btn btn-info" onclick="addSingleFromSelect('Returns')">Update</button></div><textarea id="inputReturns" class="bulk-area" placeholder="Bulk: Produto QTY"></textarea><button class="btn btn-info" onclick="processBulkFromSelect('Returns')">Bulk Process</button><div class="recent-entries-box"><h4>üïí Recent</h4><table id="recent-returns"></table></div></div></div>
        <div id="internal" class="tab-content"><div class="section-box"><h3>üè¢ Internal Use</h3><div class="entry-row"><select id="typeInternal" class="input-single"><option value="customerCare">Customer Care</option><option value="awards">Awards</option><option value="officeNeeds">Office Needs</option></select><input type="date" id="dateInternal" class="input-single today-date"><input type="text" list="productList" id="singleInternalSku" class="input-single" style="width:250px"><input type="number" id="singleInternalQty" class="input-single" style="width:70px" value="1"><button class="btn btn-danger" onclick="addSingleFromSelect('Internal')">Record</button></div><textarea id="inputInternal" class="bulk-area" placeholder="Bulk: Produto QTY"></textarea><button class="btn btn-danger" onclick="processBulkFromSelect('Internal')">Bulk Process</button><div class="recent-entries-box"><h4>üïí Recent</h4><table id="recent-internal"></table></div></div></div>
        <div id="picking" class="tab-content"><div class="section-box"><h3>üì¶ Picking Out</h3><div class="entry-row"><input type="date" id="datePicking" class="input-single today-date"><input type="text" list="productList" id="singlePickingSku" class="input-single" style="width:250px"><input type="number" id="singlePickingQty" class="input-single" style="width:70px" value="1"><button class="btn btn-primary" onclick="addSingle('picking')">Add</button></div><textarea id="inputPicking" class="bulk-area"></textarea><button class="btn btn-primary" onclick="processBulk('picking')">Bulk Process</button><div class="recent-entries-box"><h4>üïí Recent</h4><table id="recent-picking"></table></div></div></div>
        <div id="amsped" class="tab-content"><div class="section-box"><h3>üõí Amsped Sales</h3><div class="entry-row"><input type="date" id="dateAmsped" class="input-single yesterday-date"><input type="text" list="productList" id="singleAmspedSku" class="input-single" style="width:250px"><input type="number" id="singleAmspedQty" class="input-single" style="width:70px" value="1"><button class="btn btn-primary" onclick="addSingle('amsped')">Add</button></div><textarea id="inputAmsped" class="bulk-area"></textarea><button class="btn btn-primary" onclick="processBulk('amsped')">Bulk Process</button><div class="recent-entries-box"><h4>üïí Recent</h4><table id="recent-amsped"></table></div></div></div>

        <div id="b2b" class="tab-content"><div class="section-box"><h3>ü§ù B2B</h3><div class="entry-row"><input type="date" id="dateB2b" class="input-single today-date"><input type="text" list="productList" id="singleB2bSku" class="input-single" style="width:250px"><input type="number" id="singleB2bQty" class="input-single" style="width:70px" value="1"><button class="btn btn-primary" onclick="addSingle('b2b')">Add</button></div><textarea id="inputB2b" class="bulk-area" placeholder="Bulk: Produto QTY"></textarea><button class="btn btn-primary" onclick="processBulk('b2b')">Bulk Process</button><div class="recent-entries-box"><h4>üïí Recent</h4><table id="recent-b2b"></table></div></div></div>

        <!-- 8. MANAGEMENT -->
   
        <!-- WAREHOUSE MASTER (Locations / Dimensions) -->
        
        <!-- MOVEMENTS -->
        <div id="movements" class="tab-content">
            <div class="card">
                <h2>üßæ Movements (all tabs)</h2>
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:end;">
                    <div>
                        <label>From</label><br>
                        <input type="date" id="movFrom" class="input-single" onchange="renderMovements()">
                    </div>
                    <div>
                        <label>To</label><br>
                        <input type="date" id="movTo" class="input-single" onchange="renderMovements()">
                    </div>
                    <div>
                        <label>Search product</label><br>
                        <input type="text" id="movSearch" class="input-single" placeholder="Type to filter..." onkeyup="renderMovements()">
                    </div>
                    
                    <div>
                        <label>Separador</label><br>
                        <select id="movTab" class="input-single" onchange="renderMovements()">
                            <option value="all">All</option>
                        </select>
                    </div>
<div>
                        <label>View</label><br>
                        <select id="movView" class="input-single" onchange="renderMovements()">
                            <option value="detailed">Detailed</option>
                            <option value="daily">Daily summary</option>
                        </select>
                    </div>
                    <button class="btn" onclick="exportMovementsCSV()">‚¨áÔ∏è Export CSV</button>
                    <button class="btn" onclick="exportMovementsXLSX()">‚¨áÔ∏è Export XLSX</button>
                    <span id="officeSyncBadge" style="margin-left:10px; font-weight:700;">Office sync: OFF</span>
                    <button class="btn" onclick="startOfficeSync()">üîå Connect OFFICE</button>
                    <button class="btn" onclick="exportOfficeMovementsCSV()">üè∑Ô∏è Export OFFICE CSV</button>
                    <button class="btn" onclick="exportOfficeMovementsXLSX()">üè∑Ô∏è Export OFFICE XLSX</button>
                </div>
                <p style="margin-top:8px; color:#666;">Exports use <b>;</b> as separator for Excel.</p>
            </div>

            <div class="card">
                <div id="movementsSummary" style="margin-bottom:10px;"></div>
                <table>
                    <thead id="movHead"></thead>
                    <tbody id="movBody"></tbody>
                </table>
            </div>
        </div>

<div id="warehouse" class="tab-content">
            <div class="section-box" style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                <input id="warehouseFile" type="file" accept=".csv,.xlsx,.xls" class="btn" style="background:#fff; border:1px solid #ddd; padding:10px; border-radius:8px;" />
                <button class="btn btn-success" onclick="importWarehouseFile()">‚¨ÜÔ∏è Import</button>
                <button class="btn" onclick="addWarehouseRow()">+ Add row</button>
                <button class="btn btn-excel" onclick="exportWarehouseCSV()">‚¨áÔ∏è Export CSV</button>
                <button class="btn btn-danger" onclick="clearWarehouse()">üóëÔ∏è Clear</button>
            </div>

            <input type="text" id="searchWarehouse" class="search-box" style="width:100%; padding:12px; margin:10px 0 15px; border-radius:8px; border:1px solid #ddd;" placeholder="Search product or position..." onkeyup="filterTable('bodyWarehouse', 'searchWarehouse')">

            <div style="overflow-x:auto;">
                <table>
                    <thead>
                        <tr>
                            <th>Produto</th>
                            <th>Posi√ß√£o</th>
                            <th>Dimens√µes</th>
                            <th>Peso</th>
                            <th>Volume</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="bodyWarehouse"></tbody>
                </table>
            </div>

            <small style="display:block; margin-top:10px; color:#666;">
                Dica: depois de importar, podes editar cada c√©lula (uma a uma). As altera√ß√µes ficam guardadas na Firebase (Firestore).
            </small>
        </div>

             <div id="management" class="tab-content">
            <div class="section-box"><button class="btn btn-excel" onclick="exportFullExcel()">üìä Full XLSX Report</button><button class="btn btn-excel" onclick="exportAllDataXLSX()">üì¶ Export ALL (XLSX)</button><button class="btn btn-success" onclick="addNewProductMaster()">+ New Product</button><button class="btn btn-danger" onclick="resetMonth()">‚ö†Ô∏è Wipe Month</button><span style="margin-left:12px"></span><input type="file" id="mgmtInitUpload" accept=".csv,.xlsx,.xls" style="display:inline-block; max-width:260px;"><button class="btn btn-success" onclick="importInitQtyFile()">‚¨ÜÔ∏è Import Init (Produto, Quantidade)</button></div>
            <div style="overflow-x: auto;"><table><thead><tr><th>Produto</th><th>Init</th><th>Received</th><th>Adj</th><th>Pick</th><th>Amp</th><th>B2B</th><th>Act</th></tr></thead><tbody id="bodyManagement"></tbody></table></div>
        </div>
    </div>
</div>

<div id="historyModal" class="modal"><div class="modal-content"><h3 id="histTitle">Movements</h3><table id="histTable"><thead><tr><th>Date</th><th>Type</th><th>Qty</th><th>Note</th><th>Actions</th></tr></thead><tbody id="histBody"></tbody></table><br><button class="btn btn-danger" onclick="closeModal()">Close</button></div></div>



<script>
// Wrappers so inline onclick handlers always exist even with module scoping
function startOfficeSync(){
  if (window.__startOfficeSyncImpl) return window.__startOfficeSyncImpl();
  console.warn("Office sync not ready yet.");
}
function doLogin(){
  if (window.__doLoginImpl) return window.__doLoginImpl();
  console.warn("Login handler not ready yet.");
}
</script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
  import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-auth.js";
  import { initializeFirestore, doc, getDoc, setDoc, onSnapshot, collection, getDocs } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";
import { getDatabase, ref as rtdbRef, onChildAdded, onChildChanged, onChildRemoved, onValue, query, orderByChild, startAt, get } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyBvJIwx6KDSrwdnJ1o8vqvttsv9dzycY6g",
    authDomain: "inventario-57757.firebaseapp.com",
    projectId: "inventario-57757",
    storageBucket: "inventario-57757.firebasestorage.app",
    messagingSenderId: "882561809403",
    appId: "1:882561809403:web:c0d3e4c5dafa410d5d295e"
  };
  const officeConfig = {
        apiKey: "AIzaSyDExvgmtrSILCATQgE8ICJX-SVntb5lM2Y",
        authDomain: "wh-murtede.firebaseapp.com",
        databaseURL: "https://wh-murtede-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "wh-murtede",
        storageBucket: "wh-murtede.firebasestorage.app",
        messagingSenderId: "415946575714",
        appId: "1:415946575714:web:b1516b91b9735b9248e63b"
    };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  
  // Office (Realtime DB) - secondary Firebase app
  const officeApp = initializeApp(officeConfig, "office");
  const officeAuth = getAuth(officeApp);

// Ensure sessions persist so Office sync reconnects automatically on reload
try { setPersistence(auth, browserLocalPersistence); } catch(e) { /* ignore */ }
try { setPersistence(officeAuth, browserLocalPersistence); } catch(e) { /* ignore */ }


  const officeRtdb = getDatabase(officeApp);
const db = initializeFirestore(app, { experimentalForceLongPolling: true, useFetchStreams: false });

  // Expose minimal helpers to the legacy (non-module) code
  window.fb = {
    auth,
    db,
    async getDocData(pathParts) {
      const ref = doc(db, ...pathParts);
      const snap = await getDoc(ref);
      return snap.exists() ? snap.data() : null;
    },
    async setDocData(pathParts, data) {
      const ref = doc(db, ...pathParts);
      await setDoc(ref, data, { merge: true });
    },
    async listDocIds(collectionName) {
      const colRef = collection(db, collectionName);
      const snap = await getDocs(colRef);
      return snap.docs.map(d => d.id);
    },
    subscribeDocData(pathParts, cb) {
      const ref = doc(db, ...pathParts);
      window.fb.lastError = null;
      return onSnapshot(ref, { includeMetadataChanges: true }, (snap) => {
        window.fb.lastError = null;
        cb(snap.exists() ? snap.data() : null);
      }, (err) => {
        window.fb.lastError = err;
        console.error('Firestore subscribe failed', err);
        cb(null);
      });
    },
    signInWithEmailAndPassword: (email, pass) => signInWithEmailAndPassword(auth, email, pass),
    signOut: () => signOut(auth),
  };

  function roleFromEmail(email){
      if (!email) return "none";
      const e = String(email).toLowerCase().trim();

      // ADMIN (PT) ‚Äî novo padr√£o igual ao Office
      if (e.endsWith("@admin.com")) return "pt";

      // PL ‚Äî mant√©m como tens hoje
      if (e.endsWith(".pl") || e.endsWith("@pl") || e.endsWith("@pl.pl")) return "pl";

      return "none";
    }

  function setAuthUI(user){
    const userEl = document.getElementById("authUser");
    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const emailIn = document.getElementById("loginEmail");
    const passIn = document.getElementById("loginPass");

    if (user){
      userEl.textContent = user.email + " ‚úÖ";
      loginBtn.style.display = "none";
      emailIn.style.display = "none";
      passIn.style.display = "none";
      logoutBtn.style.display = "";
    } else {
      userEl.textContent = "";
      loginBtn.style.display = "";
      emailIn.style.display = "";
      passIn.style.display = "";
      logoutBtn.style.display = "none";
    }
  }

  function applyRoleToTabs(role){
    // PL: only show General. PT: show all.
    const tabBtns = Array.from(document.querySelectorAll(".tabs .tab-btn"));
    const tabContents = Array.from(document.querySelectorAll(".tab-content"));

    if (role === "pl"){
      tabBtns.forEach(btn => {
        const isGeneral = btn.getAttribute("onclick")?.includes("openTab('general')");
        btn.style.display = isGeneral ? "" : "none";
      });
      tabContents.forEach(c => c.id === "general" ? c.classList.add("active") : c.classList.remove("active"));
      // activate first visible tab button
      tabBtns.forEach(b => b.classList.remove("active"));
      const g = tabBtns.find(btn => btn.style.display !== "none");
      if (g) g.classList.add("active");
    } else if (role === "pt"){
      tabBtns.forEach(btn => btn.style.display = "");
    } else {
      // not allowed
      tabBtns.forEach(btn => btn.style.display = "none");
    }
  }

  // Login/Logout buttons called from HTML
  window.doLogin = async function(){
    try{
      const email = document.getElementById("loginEmail").value.trim();
      const pass = document.getElementById("loginPass").value;
      if(!email || !pass) return alert("Preenche email e password.");
      await signInWithEmailAndPassword(auth, email, pass);
      // login also into Office Firebase project (RTDB)
      await signInWithEmailAndPassword(officeAuth, email, pass);
      // start Office->Inventory sync after both logins
      startOfficeSync();
} catch (e){
      alert("Login falhou: " + (e?.message || e));
    }
  };

  window.doLogout = async function(){
    try{
      await signOut(auth);
    } catch(e){
      alert("Logout falhou: " + (e?.message || e));
    }
  };


  // =========================
  // Office -> Inventory Sync
  // =========================
  let officeSyncStarted = false;

  function dateToMonthKey(dateClean){
    const d = String(dateClean || "").slice(0,10);
    if(!/^\d{4}-\d{2}-\d{2}$/.test(d)) return null;
    return d.slice(0,7);
  }

  function normSku(s){
    return String(s||"").trim().toLowerCase();
  }

  function splitProds(str){
    const raw = String(str||"").trim();
    if(!raw) return [];
    return raw.split(" | ").map(x=>x.trim()).filter(Boolean);
  }

    // --- Debounced month writes to avoid Firestore write stream exhaustion ---
  const __officeMonthState = {}; // { [monthKey]: { data, loaded, loadingPromise, timer, dirty } }

  async function __loadMonthDoc(monthKey){
    if(__officeMonthState[monthKey]?.loaded) return __officeMonthState[monthKey].data;
    if(__officeMonthState[monthKey]?.loadingPromise) return __officeMonthState[monthKey].loadingPromise;
    __officeMonthState[monthKey] = __officeMonthState[monthKey] || {};
    __officeMonthState[monthKey].loadingPromise = (async ()=>{
      const data = (await window.fb.getDocData(["months", monthKey])) || { products: [], logs: [] };
      if(!Array.isArray(data.products)) data.products = [];
      if(!Array.isArray(data.logs)) data.logs = [];
      __officeMonthState[monthKey].data = data;
      __officeMonthState[monthKey].loaded = true;
      __officeMonthState[monthKey].loadingPromise = null;
      return data;
    })();
    return __officeMonthState[monthKey].loadingPromise;
  }

  function __scheduleMonthSave(monthKey){
    const st = __officeMonthState[monthKey];
    if(!st) return;
    st.dirty = true;
    if(st.timer) return;
    st.timer = setTimeout(async ()=>{
      st.timer = null;
      if(!st.dirty) return;
      st.dirty = false;
      try{
        // IMPORTANT:
        // Office sync keeps a cached month doc (st.data). If we write it back wholesale,
        // we can overwrite manual movements added in the UI after the cache was loaded.
        // So we always merge ONLY the office-sync movements into the latest Firestore doc.
        const latest = (await window.fb.getDocData(["months", monthKey])) || { products: [], logs: [] };
        if(!Array.isArray(latest.products)) latest.products = [];
        if(!Array.isArray(latest.logs)) latest.logs = [];

        const bySku = new Map();
        latest.products.forEach(p => {
          if(p && p.sku) bySku.set(normSku(p.sku), p);
          if(p && !Array.isArray(p.movements)) p.movements = [];
        });

        const officeProducts = (st.data && Array.isArray(st.data.products)) ? st.data.products : [];
        officeProducts.forEach(op => {
          if(!op || !op.sku) return;
          const key = normSku(op.sku);
          let lp = bySku.get(key);
          if(!lp){
            lp = { sku: op.sku, initial: 0, movements: [], toConfirm: 0 };
            latest.products.push(lp);
            bySku.set(key, lp);
          }
          if(!Array.isArray(lp.movements)) lp.movements = [];

          const officeMovs = Array.isArray(op.movements) ? op.movements : [];
          officeMovs
            .filter(m => String(m?.uid || "") === "office-sync")
            .forEach(om => {
              const t = String(om?.type || "");
              const sid = String(om?.sourceId || "");
              // Replace the exact office movement (type + sourceId) to avoid duplicates
              lp.movements = lp.movements.filter(m =>
                !(String(m?.uid || "") === "office-sync" && String(m?.type || "") === t && String(m?.sourceId || "") === sid)
              );
              lp.movements.push(om);
            });
        });

        await window.fb.setDocData(["months", monthKey], {
          products: latest.products,
          logs: latest.logs,
          updatedAt: new Date().toISOString(),
          updatedBy: "office-sync",
          updatedUid: "office-sync"
        });

        // Refresh cache so subsequent office updates merge from a fresher baseline
        st.data = latest;
        st.loaded = true;
      }catch(e){
        console.error("Office sync: failed to write months/"+monthKey, e);
        st.dirty = true; // retry later
      }
    }, 900);
  }

  async function applyMovementToMonth({ monthKey, sku, type, sourceId, qty, date, by, uid="office-sync" }){
    if(!monthKey || !sku) return;
    const data = await __loadMonthDoc(monthKey);

    const skuRaw = String(sku||"").trim();
    const skuKey = normSku(skuRaw);
    let p = (data.products || []).find(x => normSku(x.sku) === skuKey);
    if(!p){
      p = { sku: skuRaw, initial: 0, movements: [] };
      data.products.push(p);
    }
    if(!Array.isArray(p.movements)) p.movements = [];

    const idx = p.movements.findIndex(m => String(m.type)===String(type) && String(m.sourceId)===String(sourceId));
    const mov = {
      type,
      qty: Number(qty || 0),
      date: String(date || new Date().toISOString().slice(0,10)),
      sourceId: String(sourceId || ""),
      by: String(by || "OFFICE"),
      uid: String(uid || "office-sync")
    };
    if(idx >= 0) p.movements[idx] = mov;
    else p.movements.push(mov);

    __scheduleMonthSave(monthKey);
  }

// --- Office batch history 
  async function removeMovementFromMonth({ monthKey, sku, uid="office-sync", type=null, sourceId=null }){
    if(!monthKey || !sku) return;
    const data = await __loadMonthDoc(monthKey);

    const skuRaw = String(sku||"").trim();
    const skuKey = normSku(skuRaw);
    const p = (data.products || []).find(x => normSku(x.sku) === skuKey);
    if(!p || !Array.isArray(p.movements)) return;

    const before = p.movements.length;
    p.movements = p.movements.filter(m => {
      if(String(m.uid || "manual") !== String(uid || "office-sync")) return true;
      if(type != null && String(m.type || "") !== String(type)) return true;
      if(sourceId != null && String(m.sourceId || "") !== String(sourceId)) return true;
      return false; // remove
    });

    if(p.movements.length !== before){
      __scheduleMonthSave(monthKey);
    }
  }

// listener (handles qty edits that log as history messages) ---
  function parseInvQtyUpdateMsg(msg){
    // Example: "INV QTY UPDATE: SKU2228 TANKLESS ELECTRIC WATER HEATER | 2 -> 1"
    const m = String(msg||"").match(/^INV QTY UPDATE:\s*(.*?)\s*\|\s*(\d+)\s*->\s*(\d+)\s*$/i);
    if(!m) return null;
    return { sku: m[1], oldQty: Number(m[2]), newQty: Number(m[3]) };
  }

  async function syncBatchQtyFromHistory(batchKey, historyKey, historyVal){
    if(!batchKey || !historyKey || !historyVal) return;
    const msg = historyVal.msg || historyVal.message || "";
    const parsed = parseInvQtyUpdateMsg(msg);
    if(!parsed){
      // fallback: resync inventory snapshot if message format differs
      try{
        const metaSnap = await get(rtdbRef(officeRtdb, `active_batches/${batchKey}`));
        const b = metaSnap.val() || {};
        if(b && b.inventory) await syncBatchInventory(batchKey, b);
      }catch(e){ console.warn('History fallback resync failed', e); }
      return;
    }

    if(!window.__officeHistoryProcessed) window.__officeHistoryProcessed = {};
    if(!window.__officeHistoryProcessed[batchKey]) window.__officeHistoryProcessed[batchKey] = new Set();
    if(window.__officeHistoryProcessed[batchKey].has(historyKey)) return;
    window.__officeHistoryProcessed[batchKey].add(historyKey);

    // Need month/date/by; take from meta cache filled by syncBatchInventory
    const meta = (window.__officeBatchMetaCache && window.__officeBatchMetaCache[batchKey]) || null;
    if(!meta){
      console.warn("Batch meta not ready for history update; skipping for now", batchKey, msg);
      return;
    }
    const sku = String(parsed.sku||"").trim();
    const skuKey = normSku(sku);
    const qty = Number(parsed.newQty);
    if(!sku || !Number.isFinite(qty) || qty < 0) return;

    await applyMovementToMonth({ uid:"office-sync", 
      monthKey: meta.monthKey,
      sku,
      type: "picking",
      sourceId: batchKey,
      qty,
      date: meta.date,
      by: meta.by
    });
  }


  // --- UNDO logic: if a batch/return is deleted in Office, remove the corresponding movements in Inventory ---
  async function removeOfficeBatchMovements(batchKey){
    try{
      // Prefer cached index (fast path)
      let idx = (window.__officeBatchInvIndex && window.__officeBatchInvIndex[batchKey]) || (window.__officeBatchMetaCache && window.__officeBatchMetaCache[batchKey]) || null;
      let monthKey = idx?.monthKey || null;
      let skus = Array.isArray(idx?.skus) ? idx.skus.slice() : [];

      // Fallback: if we don't have cache (e.g. Inventory started after the batch existed),
      // fetch the archived batch from Office /deleted_batches/<batchKey> and derive SKUs from it.
      if(!monthKey || !skus.length){
        try{
          const archSnap = await get(rtdbRef(officeRtdb, `deleted_batches/${batchKey}`));
          const arch = archSnap.val() || null;
          if(arch && arch.inventory){
            const todayStr = new Date().toISOString().slice(0,10);
            monthKey = monthKey || dateToMonthKey(todayStr);
            const inv = arch.inventory || {};
            skus = Object.keys(inv).map(k => String(k||"").trim()).filter(Boolean);
          }
        }catch(e){
          // ignore; we'll warn below if still missing
        }
      }

      if(!monthKey){
        console.warn("No monthKey for deleted batch; cannot undo", batchKey);
        return;
      }
      if(!skus.length){
        console.warn("No SKU list for deleted batch; cannot undo", batchKey);
        return;
      }

      for(const sku of skus){
        await removeMovementFromMonth({
          monthKey,
          sku,
          uid: "office-sync",
          type: "picking",
          sourceId: batchKey
        });
      }

      // clean caches
      if(window.__officeBatchInvIndex) delete window.__officeBatchInvIndex[batchKey];
      if(window.__officeBatchMetaCache) delete window.__officeBatchMetaCache[batchKey];

      console.log("Undid movements for deleted batch", batchKey);
    }catch(err){
      console.error("removeOfficeBatchMovements failed", err);
    }
  }


  async function removeOfficeReturnMovements(regId, rec){
    try{
      const dc = String(rec?.dateClean || "").slice(0,10);
      const monthKey = dateToMonthKey(dc || new Date().toISOString().slice(0,10));
      const items = rec?.items || rec?.inventory || rec?.products || {};
      const skus = Object.keys(items || {}).map(k => String(k||"").trim()).filter(Boolean);
      for(const sku of skus){
        await removeMovementFromMonth({
          monthKey,
          sku,
          uid: "office-sync",
          type: "returns",
          sourceId: regId
        });
      }
      console.log("Undid movements for deleted return record", regId);
    }catch(err){
      console.error("removeOfficeReturnMovements failed", err);
    }
  }
async function syncReturnRecord(regId, r){
    if(!regId || !r) return;
    if(!String(r.mode||"").toUpperCase().startsWith("RET")) return;

    const dateClean = r.dateClean || new Date().toISOString().slice(0,10);
    const monthKey = dateToMonthKey(dateClean);
    if(!monthKey) return;

    const by = r.user || "OFFICE";
    const prods = splitProds(r.prods);
    if(!prods.length) return;

    const counts = {};
    for(const p of prods){
      const skuRaw = String(p||"").trim();
      if(!skuRaw) continue;
      const key = normSku(skuRaw);
      if(!counts[key]) counts[key] = { sku: skuRaw, qty: 0 };
      counts[key].qty += 1;
    }
    for(const {sku, qty} of Object.values(counts)){

      await applyMovementToMonth({ uid:"office-sync", 
        monthKey,
        sku,
        type: "returns",
        sourceId: regId,
        qty,
        date: String(dateClean || '').slice(0,10),
        by
      });
    }
  }

  
  
  


  // --- Sync a batch's inventory snapshot into Inventory Firestore as movements ---
  async function syncBatchInventory(batchKey, batchData){
    if(!batchKey || !batchData) return;
    // We want to reserve/abate stock immediately when the batch is created/updated in Office,
    // even if Office dateClean is in the future. So we apply the movement on TODAY in the inventory.
    const todayStr = new Date().toISOString().slice(0,10);
    const dateClean = batchData.dateClean || (batchData.createdAt ? String(batchData.createdAt).slice(0,10) : null) || todayStr;
    const monthKey = dateToMonthKey(todayStr);
    if(!monthKey) return;
    const movementDate = todayStr;
    const by = batchData.createdBy || batchData.pickedBy || "OFFICE";
    // cache meta for history-triggered updates
    if(!window.__officeBatchMetaCache) window.__officeBatchMetaCache = {};
    window.__officeBatchMetaCache[batchKey] = { monthKey, date: String(dateClean || '').slice(0,10), by };

    const inv = batchData.inventory || {};
    // keep an index so we can undo movements if the batch is deleted in Office
    if(!window.__officeBatchInvIndex) window.__officeBatchInvIndex = {};
    const __skusSeen = [];

    // inv may be {SKU:{q:1}} or {SKU:1}
    for(const [k,v] of Object.entries(inv)){
      const sku = String(k||"").trim();
      const skuKey = normSku(sku);
      const qty = (typeof v === "object" && v !== null) ? Number(v.q ?? v.qty ?? 0) : Number(v ?? 0);
      if(!sku || !Number.isFinite(qty) || qty < 0) continue;
      __skusSeen.push(sku);

      await applyMovementToMonth({
        monthKey,
        sku,
        type: "picking",
        sourceId: batchKey,
        qty,
        date: String(dateClean || '').slice(0,10),
        by,
        uid: "office-sync"
      });
    }
    // store index for delete/undo
    window.__officeBatchInvIndex[batchKey] = { monthKey, date: String(dateClean || '').slice(0,10), by, skus: Array.from(new Set(__skusSeen)) };
  }

async function ensureOfficeAuthInteractive(){
    // No prompt here. We rely on Firebase Auth persistence:
    // - First time: user logs in via Login button (logs into both projects)
    // - Next times: officeAuth.currentUser is restored automatically, and sync starts by itself
    return !!officeAuth.currentUser;
  }

  async function startOfficeSync(){
    const badge = document.getElementById("officeSyncBadge");
    const ok = await ensureOfficeAuthInteractive();
    if(!ok){
      if(badge) badge.textContent = "Office sync: OFF (no Office login)";
      console.warn("Office auth not signed in; sync not started.");
      return;
    }
    if(badge) badge.textContent = "Office sync: ON";

    if(officeSyncStarted) return;
    if(!auth.currentUser) return;
    if(!officeAuth.currentUser){
      console.warn("Office auth not signed in yet; sync not started.");
      return;
    }
    officeSyncStarted = true;
    console.log("Office->Inventory sync started.");

    // Watch active_batches (root). We filter by dateClean in code so we never miss new batches.
    const startStr = "2026-02-06";

    const batchesRef = rtdbRef(officeRtdb, "active_batches");

    function shouldSyncBatch(b){
      const dc = String(b?.dateClean || "").slice(0,10);
      const ca = String(b?.createdAt || "").slice(0,10);
      // startStr is the minimum date (inclusive). We allow sync if either dateClean OR createdAt meets it.
      return (dc && dc >= startStr) || (ca && ca >= startStr);
    }

    function attachBatchListeners(batchKey){
      if(!window.__officeBatchAttached) window.__officeBatchAttached = {};
      if(window.__officeBatchAttached[batchKey]) return;
      window.__officeBatchAttached[batchKey] = true;

      // Listen to inventory node (source of truth)
      const invRef = rtdbRef(officeRtdb, `active_batches/${batchKey}/inventory`);
      onValue(invRef, async (s2)=>{
        const inv = s2.val() || {};
        const metaSnap = await get(rtdbRef(officeRtdb, `active_batches/${batchKey}`));
        const b = metaSnap.val() || {};
        if(!shouldSyncBatch(b)) return;
        b.inventory = inv;
        syncBatchInventory(batchKey, b).catch(err=>console.error("syncBatchInventory failed", err));
      });

      // Listen to history messages; if qty edit is logged here, we trigger a resync (or set qty directly if parse succeeds)
      const histRef = rtdbRef(officeRtdb, `active_batches/${batchKey}/history`);
      onChildAdded(histRef, (hs)=>{
        syncBatchQtyFromHistory(batchKey, hs.key, hs.val()).catch(err=>console.error("syncBatchQtyFromHistory failed", err));
      });
    }

    onChildAdded(batchesRef, (snap)=>{
      const batchKey = snap.key;
      const b = snap.val() || {};
      if(shouldSyncBatch(b)) attachBatchListeners(batchKey);
    });

    onChildChanged(batchesRef, (snap)=>{
      const batchKey = snap.key;
      const b = snap.val() || {};
      if(shouldSyncBatch(b)) attachBatchListeners(batchKey);
    });

    onChildRemoved(batchesRef, (snap)=>{
      const batchKey = snap.key;
      // if a batch that was synced gets deleted, undo the movements in Inventory
      removeOfficeBatchMovements(batchKey);
    });

    // Also watch the Office archive. This guarantees undo even if the batch was never cached
    // (e.g. Inventory opened after the batch existed) and also covers the case where OFF writes
    // the archive then removes active_batches.
    const deletedBatchesRef = rtdbRef(officeRtdb, "deleted_batches");
    onChildAdded(deletedBatchesRef, (snap)=>{
      const batchKey = snap.key;
      if(!batchKey) return;
      if(!window.__officeDeletedBatchProcessed) window.__officeDeletedBatchProcessed = new Set();
      if(window.__officeDeletedBatchProcessed.has(batchKey)) return;
      window.__officeDeletedBatchProcessed.add(batchKey);
      removeOfficeBatchMovements(batchKey);
    });


    // Watch returns in registos (only recent by dateClean)
    const regsQ = query(rtdbRef(officeRtdb, "registos"), orderByChild("dateClean"), startAt(startStr));
    onChildAdded(regsQ, (snap)=>{
      syncReturnRecord(snap.key, snap.val()).catch(err=>console.error("syncReturnRecord failed", err));
    });
    onChildChanged(regsQ, (snap)=>{
      syncReturnRecord(snap.key, snap.val()).catch(err=>console.error("syncReturnRecord change failed", err));
    });
    onChildRemoved(regsQ, (snap)=>{
      removeOfficeReturnMovements(snap.key, snap.val() || {});
    });
  }
  onAuthStateChanged(auth, async (user) => {
    setAuthUI(user);
    // try start sync if both projects are authenticated
    try { startOfficeSync(); } catch(e) { console.warn(e); }

    // file:// warning
    const warn = document.getElementById("fileProtoWarn");
    if (warn) warn.style.display = (location.protocol === "file:") ? "" : "none";

    const main = document.getElementById("mainInterface");
    const init = document.getElementById("initView");

    if (!user){
      if (main) main.style.display = "none";
      if (init) init.style.display = "none";
      applyRoleToTabs("none");
      return;
    }

    const role = roleFromEmail(user.email);
    if (role === "none"){
      if (main) main.style.display = "none";
      if (init) init.style.display = "none";
      applyRoleToTabs("none");
      alert("Sem permiss√µes: apenas @admin.com (admin) ou .pl / @pl.pl (General-only).");
      return;
    }

    applyRoleToTabs(role);

    // Start/load app data (defined in the legacy script)
    if (typeof window.startAppAfterAuth === "function"){
      await window.startAppAfterAuth(role);
    }
  });

// When the OFFICE auth session becomes available (restored on reload), start sync automatically
onAuthStateChanged(officeAuth, () => {
  try { startOfficeSync(); } catch(e) { console.warn(e); }
});


</script>

<script>
    const initialSkus = []; // (Deprecated) Product list now comes from the Warehouse upload (tab ‚Äúüè∑Ô∏è Warehouse‚Äù).

    let currentMonth = "", products = [], logs = [], charts = {};
    let warehouseItems = [];
    let allData = {};
    let userRole = 'pt';
    let generalViewItems = [];
    let generalUnsub = null;
    // Cross-month open SENT shipments (so receiving next month adds stock in the month received)
    let openSentLogs = []; // [{fromMonth, id, date, sku, qty, by, uid}]
    let saveTimer = null;
    let generalSaveTimer = null;
    let lastSavedAt = 0;

    // Called by Firebase Auth module after login
    window.startAppAfterAuth = async function(role) {
        userRole = role || 'pt';

        // Set current month on first load
        const now = new Date();
        currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        const mp = document.getElementById('monthPicker');
        if (mp) mp.value = currentMonth;

        // PT-only tools
        const bf = document.getElementById('btnBackfillGeneral');
        if (bf) bf.style.display = (userRole === 'pt') ? '' : 'none';

        if (userRole === 'pl') {
            // PL accounts: General-only, real-time from Firestore "general/{YYYY-MM}"
            document.getElementById('initView').style.display = 'none';
            document.getElementById('mainInterface').style.display = 'block';
            startGeneralRealtime();
            return;
        }

        // Load warehouse master first (drives product list)
        await loadWarehouseFromFirestore();
        renderWarehouse();
        syncProductsFromWarehouse(); // keeps productList aligned with warehouse

        // Load selected month data
        await loadMonthData();
        await loadOpenSentLogsFromPreviousMonths();

        // Publish initial General view for this month (so .pl can see it)
        queueSaveGeneralView(true);
    };


    // --- Helpers: case-insensitive matching + bulk line parsing (supports product names with spaces) ---
    function normKey(v) { return (v || '').toString().trim().toLowerCase(); }
    const WARRANTY_KEYS = ['warranty pt', 'warranty es'];
    function isWarrantySku(sku){
        const k = normKey(sku);
        return WARRANTY_KEYS.includes(k);
    }

    function findProd(input) { const k = normKey(input); return products.find(p => normKey(p.sku) === k); }
    function parseBulkLine(line) {
        const parts = (line || '').toString().trim().split(/\s+/);
        if (parts.length < 2) return null;
        const qty = parseInt(parts[parts.length - 1]);
        const sku = parts.slice(0, -1).join(' ').trim();
        if (!sku || isNaN(qty)) return null;
        return { sku, qty };
    }

    // --- Auth / Actor helper (used in logs/movements + exports) ---
    function currentActorEmail() {
        try { return window.fb?.auth?.currentUser?.email || ''; } catch(e) { return ''; }
    }
    function currentActorUid() {
        try { return window.fb?.auth?.currentUser?.uid || ''; } catch(e) { return ''; }
    }


    // --- CSV / Export helpers (Excel-friendly ';' delimiter) ---
    const CSV_DELIM = ';';
    function escapeCSV(v) {
        const s = (v ?? '').toString();
        if (s.includes('"')) return '"' + s.replace(/"/g, '""') + '"';
        if (s.includes('\n') || s.includes('\r') || s.includes(CSV_DELIM) || s.includes(',')) return '"' + s + '"';
        return s;
    }
    function downloadCSV(headers, rows, filename) {
        const lines = [];
        lines.push(`sep=${CSV_DELIM}`);
        lines.push(headers.map(escapeCSV).join(CSV_DELIM));
        rows.forEach(r => lines.push(headers.map(h => escapeCSV(r[h])).join(CSV_DELIM)));
        const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }



    // ---- Master Product List (Warehouse upload) ----
    function masterSkuLines() {
        return (warehouseItems || [])
            .map(r => (r?.produto ?? '').toString().trim())
            .filter(Boolean);
    }

    function parseSkuLine(line) {
        // Warehouse master list now provides ONLY the product name (coluna A: Produto).
        // We keep the internal field name `sku` for compatibility across tabs, but it equals the product string.
        const produto = (line || '').toString().trim();
        return { sku: produto, name: produto };
    }

    function buildBaseProducts() {
        return masterSkuLines().map(line => {
            const { sku, name } = parseSkuLine(line);
            return { sku, name, initial: 0, movements: [], toConfirm: 0 };
        });
    }

    function reconcileWithMaster(storedProducts) {
        const map = new Map();
        (storedProducts || []).forEach(p => { if (p && p.sku) map.set(p.sku, p); });

        const base = buildBaseProducts();
        base.forEach(p => {
            const old = map.get(p.sku);
            if (old) {
                p.initial = Number(old.initial) || 0;
                p.movements = old.movements || [];
                p.toConfirm = old.toConfirm || 0;
            }
        });
        return base;
    }

    function syncProductsFromWarehouse() {
        // If a month is already loaded, rebuild its products from the warehouse master list
        if (currentMonth && allData[currentMonth]) {
            products = reconcileWithMaster(allData[currentMonth].products || []);
            allData[currentMonth].products = products;
            save(); flushSaveMonth(); renderAll();
        } else {
            // No month loaded yet; just keep datalist consistent
            products = reconcileWithMaster(products || []);
            updateDatalist();
        }
    }

    window.onload = () => {
        // Firebase Auth will call startAppAfterAuth() after login
        const warn = document.getElementById('fileProtoWarn');
        if (warn) warn.style.display = (location.protocol === 'file:') ? '' : 'none';
    };

    async function changeMonth() {
        currentMonth = document.getElementById('monthPicker').value;
        if (userRole === 'pl') {
            startGeneralRealtime();
        } else {
            await loadMonthData();
            // publish General AFTER month data is loaded, so PL sees the right values
            queueSaveGeneralView(true);
        }
    }

    async function loadMonthData() {
        if (!currentMonth) return;
        if (userRole === 'pl') { startGeneralRealtime(); return; }

        // Fetch from Firestore
        let data = null;
        try {
            if (window.fb) data = await window.fb.getDocData(['months', currentMonth]);
        } catch(e) {
            console.error('Load month failed', e);
        }

        if (data) {
            products = reconcileWithMaster(data.products || []);
            logs = data.logs || [];
            products.forEach(p => { if(p.toConfirm === undefined) p.toConfirm = 0; });
            document.getElementById('initView').style.display = 'none';
            document.getElementById('mainInterface').style.display = 'block';
            allData[currentMonth] = { products, logs };
            await loadOpenSentLogsFromPreviousMonths();
            renderAll();
            queueSaveGeneralView(true);
        } else {
            document.getElementById('mainInterface').style.display = 'none';
            document.getElementById('initView').style.display = 'flex';
        }
    }

    function monthMinus(monthStr, n) {
        // monthStr: YYYY-MM
        const [y, m] = monthStr.split('-').map(x => parseInt(x,10));
        let yy = y, mm = m - n;
        while (mm <= 0) { yy -= 1; mm += 12; }
        return `${yy}-${String(mm).padStart(2,'0')}`;
    }

    async function findPreviousMonthData() {
        // Look back up to 24 months for previous initialized month
        for (let i=1; i<=24; i++){
            const key = monthMinus(currentMonth, i);
            try{
                const d = await window.fb.getDocData(['months', key]);
                if (d) return { key, data: d };
            } catch(e){}
        }
        return null;
    }

    // ---- Cross-month: load open SENT logs from previous months (still not received) ----
    async function loadOpenSentLogsFromPreviousMonths() {
        openSentLogs = [];
        if (!window.fb || !currentMonth) return;
        if (userRole === 'pl') return; // PL doesn't need this; it uses general/{month} snapshot

        // Look back up to 6 months to find outstanding SENT shipments
        for (let i = 1; i <= 24; i++) {
            const mKey = monthMinus(currentMonth, i);
            try {
                const d = await window.fb.getDocData(['months', mKey]);
                if (!d || !Array.isArray(d.logs)) continue;
                d.logs.forEach(l => {
                    if (!l) return;
                    if (l.status !== 'SENT') return;
                    // If received in or before the month we're viewing, it's no longer in transit for this month.
                    if (l.receivedInMonth && String(l.receivedInMonth).localeCompare(String(currentMonth)) <= 0) return;
                    openSentLogs.push({
                        fromMonth: mKey,
                        id: l.id,
                        date: l.date,
                        sku: l.sku,
                        qty: Number(l.qty) || 0,
                        note: l.note || '',
                        by: l.by || '',
                        uid: l.uid || ''
                    });
                });
            } catch(e) {
                console.warn('Failed to load previous month logs', mKey, e);
            }
        }

        // Sort: newest first
        openSentLogs.sort((a,b) => (b.date||'').localeCompare(a.date||'') || (a.sku||'').localeCompare(b.sku||''));
    }

    async function markSourceSentAsReceived(fromMonth, sourceId, receivedInMonth, arrivalDate, receivedQty) {
        if (!window.fb) return;
        try {
            const d = await window.fb.getDocData(['months', fromMonth]);
            if (!d || !Array.isArray(d.logs)) return;
            const logsArr = d.logs;
            const idx = logsArr.findIndex(x => x && x.id === sourceId);
            if (idx < 0) return;

            // Keep status as SENT for historical month snapshot, but mark it as already received elsewhere
            logsArr[idx].receivedInMonth = receivedInMonth;
            logsArr[idx].receivedAt = arrivalDate;
            logsArr[idx].receivedQty = receivedQty;
            logsArr[idx].receivedBy = currentActorEmail();
            logsArr[idx].receivedUid = currentActorUid();

            await window.fb.setDocData(['months', fromMonth], { logs: logsArr, updatedAt: new Date().toISOString() });
        } catch(e) {
            console.error('Failed to mark source SENT as received', e);
        }
    }


    // If a previous-month SENT is only partially received, keep it open by reducing its qty.
    // This preserves the ability to receive the remaining quantity later.
    async function updateSourceSentRemaining(fromMonth, sourceId, remainingQty, receivedInMonth, arrivalDate, receivedQty) {
        if (!window.fb) return;
        try {
            const d = await window.fb.getDocData(['months', fromMonth]);
            if (!d || !Array.isArray(d.logs)) return;
            const logsArr = d.logs;
            const idx = logsArr.findIndex(x => x && x.id === sourceId);
            if (idx < 0) return;

            const src = logsArr[idx];
            src.qty = remainingQty;

            src.partialReceipts = Array.isArray(src.partialReceipts) ? src.partialReceipts : [];
            src.partialReceipts.push({
                receivedInMonth,
                receivedAt: arrivalDate,
                receivedQty,
                by: currentActorEmail(),
                uid: currentActorUid()
            });
            src.lastPartialAt = arrivalDate;

            // Make sure it stays open (do NOT set receivedInMonth)
            delete src.receivedInMonth;

            await window.fb.setDocData(['months', fromMonth], { logs: logsArr, updatedAt: new Date().toISOString() });
        } catch(e) {
            console.error('Failed to update source SENT remaining qty', e);
        }
    }

    async function initializeMonth(carryOver) {
        if (!window.fb) return alert('Firebase not ready.');
        if (userRole === 'pl') return alert('A tua conta (.pl) √© apenas leitura.');

        let newProds = buildBaseProducts();
        if (carryOver) {
            const prev = await findPreviousMonthData();
            if (prev && prev.data) {
                const prevProducts = reconcileWithMaster(prev.data.products || []);
                const prevLogs = prev.data.logs || [];
                newProds.forEach(p => {
                    const old = prevProducts.find(op => op.sku === p.sku);
                    if (old) p.initial = calculateStock(old, 'real', prevLogs);
                    p.toConfirm = 0;
                });
            }
        }

        products = newProds;
        logs = [];

        allData[currentMonth] = { products, logs };

        await window.fb.setDocData(['months', currentMonth], {
            products,
            logs,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
                updatedBy: currentActorEmail(),
                updatedUid: currentActorUid(),
                updatedBy: currentActorEmail(),
                updatedUid: currentActorUid()
        });

        await loadMonthData();
    }


    function calculateStock(p, type, currentLogs) {
        const added = sum(p,'adjust') + sum(p,'returns') + sum(p,'refunds') + sum(p,'recovered') + sum(p, 'RECEIVED');
        const internal = sum(p,'customerCare') + sum(p,'awards') + sum(p,'officeNeeds');
        if(type === 'real') return p.initial + added - internal - sum(p,'picking') - sum(p,'b2b');
        return p.initial + added - internal - sum(p,'amsped') - sum(p,'b2b');
    }

    function sum(prod, type) { return prod.movements.filter(m => m.type === type).reduce((acc, curr) => acc + curr.qty, 0); }
    function save() {
        // Firestore save (debounced)
        allData[currentMonth] = { products, logs };
        queueSaveMonth();
        // publish General view fast so PL sees near-instant updates
        queueSaveGeneralView(true);
    }

    function queueSaveMonth() {
        if (!window.fb || !currentMonth) return;
        if (userRole === 'pl') return; // PL is read-only
        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(flushSaveMonth, 150);
    }


    function buildGeneralViewItems() {
        // Returns list: { sku, real, amsped, transit }
        return (products || []).map(p => {
            const real = calculateStock(p, 'real', logs);
            const amsped = calculateStock(p, 'amsped', logs);
            const transitCurrent = logs.filter(l => normKey(l.sku) === normKey(p.sku) && l.status === 'SENT' && (!l.receivedInMonth || String(l.receivedInMonth).localeCompare(String(currentMonth)) > 0))
                                .reduce((a,c)=>a + (Number(c.qty)||0), 0);
            const transitPrev = (openSentLogs || []).filter(l => normKey(l.sku) === normKey(p.sku))
                                .reduce((a,c)=>a + (Number(c.qty)||0), 0);
            const transit = transitCurrent + transitPrev;
            return { sku: p.sku, real: Number(real)||0, amsped: Number(amsped)||0, transit: Number(transit)||0 };
        }).sort((a,b) => {
            const aw = isWarrantySku(a.sku), bw = isWarrantySku(b.sku);
            if (aw && !bw) return 1;
            if (!aw && bw) return -1;
            return (a.real - b.real) || a.sku.localeCompare(b.sku, undefined, {numeric:true});
        });
    }

    function queueSaveGeneralView(immediate=false) {
        if (!window.fb || !currentMonth) return;
        if (userRole === 'pl') return; // PL can't write
        if (generalSaveTimer) clearTimeout(generalSaveTimer);
        const delay = immediate ? 0 : 150;
        generalSaveTimer = setTimeout(flushSaveGeneralView, delay);
    }

    async function flushSaveGeneralView() {
        try {
            if (!window.fb || !currentMonth) return;
            if (userRole === 'pl') return;
            const items = buildGeneralViewItems();
            await window.fb.setDocData(['general', currentMonth], {
                items,
                updatedAt: new Date().toISOString()
            });
        } catch (e) {
            console.error('Firestore general view save failed', e);
        }
    }

    // PT helper: publish General snapshots for ALL saved months so .pl can view historical months too
    async function backfillGeneralViews() {
        try {
            if (!window.fb || userRole === 'pl') return;
            const btn = document.getElementById('btnBackfillGeneral');
            if (btn) { btn.disabled = true; btn.textContent = '‚è≥ A publicar...'; }

            const monthIds = await window.fb.listDocIds('months');
            monthIds.sort((a,b) => String(a).localeCompare(String(b)));

            // Prefetch all months (products + logs) once
            const monthDataMap = {};
            for (const mid of monthIds) {
                try {
                    const d = await window.fb.getDocData(['months', mid]);
                    if (d) monthDataMap[mid] = d;
                } catch(e) {
                    console.warn('Backfill prefetch failed for', mid, e);
                }
            }

            function sentIsOpenAsOf(log, targetMonth) {
                if (!log || log.status !== 'SENT') return false;
                if (!log.receivedInMonth) return true;
                return String(log.receivedInMonth).localeCompare(String(targetMonth)) > 0;
            }

            for (const mid of monthIds) {
                const data = monthDataMap[mid];
                if (!data) continue;

                const monthProducts = reconcileWithMaster(data.products || []);

                const transitBySku = {};
                for (const fromMonth of monthIds) {
                    if (String(fromMonth).localeCompare(String(mid)) > 0) break;
                    const d2 = monthDataMap[fromMonth];
                    if (!d2 || !Array.isArray(d2.logs)) continue;
                    d2.logs.forEach(l => {
                        if (!sentIsOpenAsOf(l, mid)) return;
                        const k = normKey(l.sku);
                        transitBySku[k] = (transitBySku[k] || 0) + (Number(l.qty) || 0);
                    });
                }

                const items = (monthProducts || []).map(p => {
                    const real = (p.initial || 0)
                        + (p.movements||[]).filter(m => ['adjust','returns','refunds','recovered','RECEIVED'].includes(m.type)).reduce((a,c)=>a+(Number(c.qty)||0),0)
                        - (p.movements||[]).filter(m => ['customerCare','awards','officeNeeds'].includes(m.type)).reduce((a,c)=>a+(Number(c.qty)||0),0)
                        - (p.movements||[]).filter(m => ['picking','b2b'].includes(m.type)).reduce((a,c)=>a+(Number(c.qty)||0),0);

                    const amsped = (p.initial || 0)
                        + (p.movements||[]).filter(m => ['adjust','returns','refunds','recovered','RECEIVED'].includes(m.type)).reduce((a,c)=>a+(Number(c.qty)||0),0)
                        - (p.movements||[]).filter(m => ['customerCare','awards','officeNeeds'].includes(m.type)).reduce((a,c)=>a+(Number(c.qty)||0),0)
                        - (p.movements||[]).filter(m => ['amsped','b2b'].includes(m.type)).reduce((a,c)=>a+(Number(c.qty)||0),0);

                    const transit = transitBySku[normKey(p.sku)] || 0;

                    return { sku: p.sku, real: Number(real)||0, amsped: Number(amsped)||0, transit: Number(transit)||0 };
                }).sort((a,b) => (a.real - b.real) || String(a.sku).localeCompare(String(b.sku), undefined, {numeric:true}));

                await window.fb.setDocData(['general', mid], {
                    items,
                    updatedAt: new Date().toISOString(),
                    backfilledAt: new Date().toISOString(),
                    backfilledBy: currentActorEmail()
                });
            }

            alert('Publica√ß√£o conclu√≠da: .pl j√° consegue ver todos os meses gravados.');
        } catch (e) {
            console.error(e);
            alert('Erro ao publicar meses para .pl: ' + (e?.message || e));
        } finally {
            const btn = document.getElementById('btnBackfillGeneral');
            if (btn) { btn.disabled = false; btn.textContent = 'üì£ Publicar meses p/ PL'; }
        }
    }

    function startGeneralRealtime() {
        if (!window.fb || !currentMonth) return;
        // subscribe (and replace previous)
        if (generalUnsub) { try { generalUnsub(); } catch(e){} }
        generalUnsub = window.fb.subscribeDocData(['general', currentMonth], (data) => {
            generalViewItems = (data && Array.isArray(data.items)) ? data.items : [];
            const upd = (data && data.updatedAt) ? data.updatedAt : null;
            const el = document.getElementById('generalUpdatedAt');
            if (el) el.textContent = upd ? ('Last update: ' + new Date(upd).toLocaleString()) : 'Last update: ‚Äî';
            // ensure main UI visible for PL
            const init = document.getElementById('initView');
            const main = document.getElementById('mainInterface');
            if (init) init.style.display = 'none';
            if (main) main.style.display = 'block';
            renderGeneral();
        });
    }

    function reconnectGeneral(){
        // Forces re-subscribe (useful if rules/domain were updated)
        startGeneralRealtime();
    }

    async function flushSaveMonth() {
        try {
            if (!window.fb || !currentMonth) return;
            if (userRole === 'pl') return;
            const payload = {
                products: products || [],
                logs: logs || [],
                updatedAt: new Date().toISOString()
            };
            await window.fb.setDocData(['months', currentMonth], payload);
            // also publish General view immediately for PL realtime
            await flushSaveGeneralView();
            lastSavedAt = Date.now();
            // Keep the public General view in sync for .pl accounts
            queueSaveGeneralView(true);
        } catch (e) {
            console.error('Firestore save failed', e);
        }
    }


    function renderAll() {
        setDates(); updateDatalist(); renderGeneral(); renderOrderInventory(); renderShipments(); renderManagement(); renderMiniDash(); renderRecentLogs(); renderWarehouse(); renderMovements();
    }

    function updateDatalist() {
        const dl = document.getElementById('productList'); dl.innerHTML = '';
        products.forEach(p => dl.innerHTML += `<option value="${p.sku}">${p.sku}</option>`);
    }

    function qtyClass(v) {
        if (v === null || v === undefined || v === '' || v === '-') return '';
        const n = Number(v);
        if (Number.isNaN(n)) return '';
        if (n < 0) return 'qty-neg';
        if (n <= 10) return 'qty-low';
        if (n <= 199) return 'qty-mid';
        if (n <= 500) return 'qty-good';
        return 'qty-high'; // 501+
    }

    function qtyCell(v) {
        if (v === null || v === undefined) v = 0;
        if (v === '-') return `<div class="qty-wrap"><div class="qty-num">-</div><div class="qty-bar"></div></div>`;
        const cls = qtyClass(v);
        return `<div class="qty-wrap"><div class="qty-num">${v}</div><div class="qty-bar ${cls}"></div></div>`;
    }

    function renderGeneral() {
        const bodyG = document.getElementById('bodyGeneral'); bodyG.innerHTML = '';

        // Data source:
        // - PT: compute from products/logs
        // - PL: read-only realtime snapshot from Firestore general/{YYYY-MM}
        let rows = [];
        if (userRole === 'pl') {
            rows = (generalViewItems || []).map(it => ({
                sku: it.sku,
                real: Number(it.real) || 0,
                amsped: Number(it.amsped) || 0,
                transit: Number(it.transit) || 0
            })).sort((a,b) => {
                const aw = isWarrantySku(a.sku), bw = isWarrantySku(b.sku);
                if (aw && !bw) return 1;
                if (!aw && bw) return -1;
                return (a.real - b.real) || String(a.sku).localeCompare(String(b.sku), undefined, {numeric:true});
            });
        } else {
            rows = buildGeneralViewItems();
        }
        if (userRole === 'pl' && rows.length === 0) {
            const err = window.fb?.lastError;
            const msg = err ? ('Sem acesso a dados (regras Firestore). Erro: ' + (err.message || err)) :
                              'Ainda n√£o existe snapshot do General para este m√™s. Um utilizador .pt precisa abrir/guardar este m√™s uma vez para publicar.';
            bodyG.innerHTML = `<tr><td colspan="4" style="padding:14px; background:#fff3cd; border:1px solid #ffeeba; border-radius:10px;">
                ${msg}
            </td></tr>`;
            return;
        }


        const normalRows = (rows || []).filter(r => !isWarrantySku(r.sku));
        const warrantyRows = (rows || []).filter(r => isWarrantySku(r.sku));

        const renderRow = ({sku, real, amsped, transit}) => {
            bodyG.innerHTML += `<tr>
                <td><b>${sku}</b></td>
                <td class="stock-val real-col">${qtyCell(real)}</td>
                <td class="stock-val amsped-col">${qtyCell(amsped)}</td>
                <td class="transit-val">${(transit||0)}</td>
            </tr>`;
        };

        normalRows.forEach(renderRow);

        if (warrantyRows.length){
            bodyG.innerHTML += `<tr>
                <td colspan="4" style="padding:10px; background:#f8f9fa; border-top:2px solid #e9ecef; font-weight:700;">
                    WARRANTY (sempre no fim)
                </td>
            </tr>`;
            warrantyRows.forEach(renderRow);
        }
    }


    // v44: PRIORITY SORTING LOGIC
    function renderOrderInventory() {
        const body = document.getElementById('bodyOrderInventory'); body.innerHTML = '';
        
        // Calculate priority for each item
        let prioritized = products.map(p => {
            const real = calculateStock(p, 'real', logs);
            const amsped = calculateStock(p, 'amsped', logs);
            const sentCurrent = logs
                .filter(l => normKey(l.sku) === normKey(p.sku) && l.status === 'SENT' && (!l.receivedInMonth || String(l.receivedInMonth).localeCompare(String(currentMonth)) > 0))
                .reduce((a,c)=>a + (Number(c.qty)||0), 0);
            const sentPrev = (openSentLogs || [])
                .filter(l => normKey(l.sku) === normKey(p.sku))
                .reduce((a,c)=>a + (Number(c.qty)||0), 0);
            const sent = sentCurrent + sentPrev;
            const ord = logs.filter(l => normKey(l.sku) === normKey(p.sku) && l.status === 'ORDER').reduce((a,c)=>a+c.qty,0);
            const toConf = p.toConfirm || 0;
            
            // Priority Rule: (Stock Real + Stock Sent) - To Confirm
            const coverage = (real + sent) - toConf;
            const isUrgent = coverage < 0;
            
            return { p, real, amsped, sent, ord, toConf, coverage, isUrgent };
        });

        // Sorting: 
        // 1. Urgent items first (most negative coverage first)
        // 2. Others by lowest real stock
        prioritized.sort((a, b) => {
            const aw = isWarrantySku(a.p.sku), bw = isWarrantySku(b.p.sku);
            if (aw && !bw) return 1;
            if (!aw && bw) return -1;

            if (a.isUrgent && !b.isUrgent) return -1;
            if (!a.isUrgent && b.isUrgent) return 1;
            if (a.isUrgent && b.isUrgent) return a.coverage - b.coverage;
            return a.real - b.real;
        });

        const normalItems = prioritized.filter(it => !isWarrantySku(it.p.sku));
        const warrantyItems = prioritized.filter(it => isWarrantySku(it.p.sku));

        const renderItem = (item) => {
            const rowClass = item.isUrgent ? 'urgent-row' : '';
            body.innerHTML += `<tr class="${rowClass}">
                <td><b>${item.p.sku}</b></td>
                <td class="real-col stock-val">${item.real}</td>
                <td class="amsped-col stock-val">${item.amsped}</td>
                <td class="transit-val">${item.sent || '-'}</td>
                <td class="confirm-col">${item.toConf || '-'}</td>
                <td class="order-col">${item.ord || '-'}</td>
            </tr>`;
        };

        normalItems.forEach(renderItem);

        if (warrantyItems.length){
            body.innerHTML += `<tr>
                <td colspan="6" style="padding:10px; background:#f8f9fa; border-top:2px solid #e9ecef; font-weight:700;">
                    WARRANTY (sempre no fim)
                </td>
            </tr>`;
            warrantyItems.forEach(renderItem);
        }
    }

    function updateToConfirm(mode) {
        if(mode === 'single') {
            const s = document.getElementById('confSku').value.trim();
            const q = parseInt(document.getElementById('confQty').value);
            const p = findProd(s);
            if(p && !isNaN(q)) { p.toConfirm = q; }
            document.getElementById('confSku').value = ""; document.getElementById('confQty').value = "";
        } else {
            const text = document.getElementById('inputToConfirm').value.trim();
            text.split('\n').forEach(line => {
                const parts = line.trim().split(/\s+/);
                if(parts.length < 2) return;
                const sku = parts.slice(0, -1).join(' ').trim();
                const qty = parseInt(parts[parts.length-1]);
                const p = findProd(sku);
                if(p && !isNaN(qty)) p.toConfirm = qty;
            });
            document.getElementById('inputToConfirm').value = "";
        }
        save(); flushSaveMonth(); renderAll();
    }

    function clearToConfirm() { if(confirm("Clear ALL 'TO CONFIRM' values?")) { products.forEach(p => p.toConfirm = 0); save(); flushSaveMonth(); renderAll(); } }

    function renderShipments() {
        const body = document.getElementById('bodyShipments');
        if (!body) return;
        body.innerHTML = '';

        // Combine current month logs + open SENT from previous months
        const combined = [];

        (logs || []).forEach((l, i) => {
            combined.push({ ...l, __source: 'current', __idx: i, __fromMonth: currentMonth });
        });

        (openSentLogs || []).forEach((l) => {
            combined.push({
                date: l.date,
                sku: l.sku,
                qty: l.qty,
                status: 'SENT',
                id: l.id,
                note: l.note || '',
                by: l.by || '',
                uid: l.uid || '',
                __source: 'prev',
                __idx: null,
                __fromMonth: l.fromMonth
            });
        });

        // Sort by date desc then product
        combined.sort((a,b) => (b.date||'').localeCompare(a.date||'') || (a.sku||'').localeCompare(b.sku||''));

        combined.forEach((l) => {
            const isPrev = l.__source === 'prev';
            const statusLabel = isPrev ? 'SENT (prev)' : l.status;
            const badgeClass = (l.status || '').toLowerCase();

            let acts = '';
            if (l.status === 'SENT') {
                if (isPrev) {
                    acts += `<button class="btn btn-success" onclick="receivePrevSent('${l.__fromMonth}', ${l.id})">Receive</button> `;
                } else {
                    acts += `<button class="btn btn-success" onclick="receiveLog(${l.__idx})">Receive</button> `;
                }
            }

            if (!isPrev) {
                acts += `<button class="btn btn-edit" onclick="editLog(${l.__idx})">Edit</button> ` +
                        `<button class="btn btn-danger" onclick="deleteLog(${l.__idx})">X</button>`;
            } else {
                acts += `<span style="font-size:12px; color:#666;">(sent em ${l.__fromMonth})</span>`;
            }

            body.innerHTML += `<tr>
                <td>${l.date}</td>
                <td>${l.sku}</td>
                <td><span class="badge bg-${badgeClass}">${statusLabel}</span></td>
                <td>${l.qty}</td>
                <td>${l.arrivalDate || '-'}</td>
                <td>${(l.note||'-')}</td>
                <td>${acts}</td>
            </tr>`;
        });
    }

    async function receivePrevSent(fromMonth, sourceId) {
        // Receive a SENT that was created in a previous month:
        // - Keep the original log as SENT (historical),
        // - Create RECEIVED in the CURRENT month (so inventory increases in the month received),
        // - Mark the original as receivedInMonth to avoid showing it again as "open".
        const src = (openSentLogs || []).find(x => x.fromMonth === fromMonth && x.id === sourceId);
        if (!src) return alert('Shipment not found (maybe already received).');

        const qty = parseInt(prompt("Confirmed Qty Received:", src.qty));
        const date = prompt("Arrival Date (YYYY-MM-DD):", new Date().toISOString().split('T')[0]);
        if (isNaN(qty) || !date) return;

        // Create a RECEIVED movement in the CURRENT month
        const p = findProd(src.sku);
        if (p) {
            p.movements.push({ type: 'RECEIVED', qty, date, logId: sourceId, by: currentActorEmail(), uid: currentActorUid() });
        } else {
            alert('Produto n√£o encontrado no m√™s atual. Confirma se existe no Warehouse master.');
            return;
        }

        // Add a RECEIVED log in current month for tracking/exports
        logs.push({
            date,
            sku: src.sku,
            qty: qty,
            status: 'RECEIVED',
            id: Date.now(),
            arrivalDate: date,
            receivedQty: qty,
            sourceMonth: fromMonth,
            sourceId: sourceId,
            note: src.note || '',
            by: currentActorEmail(),
            uid: currentActorUid()
        });

        // Update previous month SENT:
        // - If fully received, mark it as receivedInMonth (so it closes)
        // - If partially received, reduce its qty and keep it open (remaining stays SENT)
        if (qty < parseInt(src.qty)) {
            const remaining = parseInt(src.qty) - qty;
            await updateSourceSentRemaining(fromMonth, sourceId, remaining, currentMonth, date, qty);
        } else {
            await markSourceSentAsReceived(fromMonth, sourceId, currentMonth, date, qty);
        }

        // Refresh open list + save
        await loadOpenSentLogsFromPreviousMonths();
        save(); flushSaveMonth(); renderAll();
    }


    function addOrderLog(status) {
        const prefix = status === 'ORDER' ? 'ord' : 'ship';
        const date = document.getElementById(prefix + 'Date').value;
        const sku = document.getElementById(prefix + 'Sku').value.trim();
        const qty = parseInt(document.getElementById(prefix + 'Qty').value);
        const note = (status === 'SENT' && document.getElementById('shipNote')) ? (document.getElementById('shipNote').value || '').trim() : '';
        if(!date || !sku || isNaN(qty)) return alert("Check fields");
        logs.push({ date, sku, qty, status, note, id: Date.now(), by: currentActorEmail(), uid: currentActorUid() });
        save(); flushSaveMonth(); renderAll();
        document.getElementById(prefix + 'Sku').value = ''; 
        document.getElementById(prefix + 'Qty').value = '';
        if (status === 'SENT' && document.getElementById('shipNote')) document.getElementById('shipNote').value = '';
    }

    function processBulkOrderLog(status) {
        const prefix = status === 'ORDER' ? 'ord' : 'ship';
        const dateEl = document.getElementById(prefix + 'Date');
        const date = dateEl ? dateEl.value : '';
        const note = (status === 'SENT' && document.getElementById('shipNote')) ? (document.getElementById('shipNote').value || '').trim() : '';
        const textEl = document.getElementById(status === 'ORDER' ? 'inputOrdBulk' : 'inputShipBulk');
        const text = (textEl && textEl.value ? textEl.value : '').trim();
        if(!date) return alert("Select a date first");
        if(!text) return;
        const lines = text.split('\n');
        const base = Date.now();
        lines.forEach((line, i) => {
            const parsed = parseBulkLine(line);
            if(!parsed) return;
            const { sku, qty } = parsed;
            logs.push({ date, sku, qty: Math.abs(qty), status, note, id: base + i, by: currentActorEmail(), uid: currentActorUid() });
        });
        save(); flushSaveMonth(); renderAll();
        if(textEl) textEl.value = "";
    }

    function receiveLog(idx) {
        const src = logs[idx];
        if (!src) return;
        if (src.status !== 'SENT') return;
        const qtyRec = parseInt(prompt("Confirmed Qty Received:", src.qty));
        const date = prompt("Arrival Date (YYYY-MM-DD):", new Date().toISOString().split('T')[0]);
        if (isNaN(qtyRec) || !date) return;

        const sentQty = parseInt(src.qty);
        if (isNaN(sentQty) || sentQty <= 0) return;

        if (qtyRec > sentQty) return alert("Qty received cannot be higher than Qty SENT.");

        // Add RECEIVED movement (inventory increases in this month)
        const p = findProd(src.sku);
        if (p) {
            p.movements.push({ type: 'RECEIVED', qty: qtyRec, date, logId: src.id, by: currentActorEmail(), uid: currentActorUid() });
        }

        // Create a RECEIVED log entry (keeps trace + exports)
        logs.push({
            date,
            sku: src.sku,
            qty: qtyRec,
            status: 'RECEIVED',
            id: Date.now(),
            arrivalDate: date,
            receivedQty: qtyRec,
            sourceMonth: currentMonth,
            sourceId: src.id,
            note: src.note || '',
            by: currentActorEmail(),
            uid: currentActorUid()
        });

        const remaining = sentQty - qtyRec;

        if (remaining > 0) {
            // Keep the original as SENT with the remaining qty (so you can receive later)
            src.qty = remaining;
            // keep src.status = 'SENT'
            // register partials (optional)
            src.partialReceipts = Array.isArray(src.partialReceipts) ? src.partialReceipts : [];
            src.partialReceipts.push({ month: currentMonth, date, qty: qtyRec, by: currentActorEmail(), uid: currentActorUid() });
            src.lastPartialAt = date;
        } else {
            // Fully received: mark original as received (historical)
            src.status = 'RECEIVED';
            src.arrivalDate = date;
            src.receivedQty = qtyRec;
            src.receivedBy = currentActorEmail();
            src.receivedUid = currentActorUid();
        }

        save(); flushSaveMonth(); renderAll();
    }

    function editLog(idx) {
        const log = logs[idx];
        const nD = prompt("Date:", log.date); const nS = (prompt("Produto:", log.sku) || '').toString().trim(); const nQ = parseInt(prompt("Qty:", log.qty));
        if(nD && nS && !isNaN(nQ)) {
            log.date = nD; log.sku = nS; log.qty = nQ;
            if(log.status === 'RECEIVED') {
                const p = findProd(log.sku);
                const m = p.movements.find(move => move.logId === log.id);
                if(m) { m.qty = nQ; m.date = log.arrivalDate; }
            }
            save(); flushSaveMonth(); renderAll();
        }
    }

    function renderRecentLogs() {
        const bodyId = {'adjust':'recent-adjust','returns':'recent-returns','internal':'recent-internal','picking':'recent-picking','amsped':'recent-amsped','b2b':'recent-b2b'};
        const types = {'adjust':['adjust'],'returns':['returns','refunds','recovered'],'internal':['customerCare','awards','officeNeeds'],'picking':['picking'],'amsped':['amsped'],'b2b':['b2b']};
        Object.keys(bodyId).forEach(k => {
            const b = document.getElementById(bodyId[k]); if(!b) return; b.innerHTML = '';
            let moves = []; products.forEach((p,pi)=>p.movements.forEach((m,mi)=>{if(types[k].includes(m.type)) moves.push({...m,pi,mi,sku:p.sku})}));
            moves.sort((a,b)=>b.mi-a.mi).slice(0,8).forEach(m => {
                b.innerHTML += `<tr><td>${m.date}</td><td>${m.sku}</td><td>${m.qty}</td><td><button class="btn btn-danger" onclick="deleteMove(${m.pi},${m.mi})">X</button></td></tr>`;
            });
        });
    }

    function renderManagement() {
        const bodyM = document.getElementById('bodyManagement'); bodyM.innerHTML = '';
        products.forEach((p, i) => {
            bodyM.innerHTML += `<tr><td>${p.sku}</td><td><input type="number" class="input-single" style="width:40px" value="${p.initial}" onchange="products[${i}].initial=parseInt(this.value);save(); flushSaveMonth(); renderAll()"></td><td>${sum(p,'RECEIVED')}</td><td>${sum(p,'adjust')}</td><td>${sum(p,'picking')}</td><td>${sum(p,'amsped')}</td><td>${sum(p,'b2b')}</td><td><button onclick="showHistory(${i})">üìú</button></td></tr>`;
        });
    }

    function exportFullExcel() {
        const wb = XLSX.utils.book_new();
        const summary = products.map(p => ({ Produto: p.sku, Initial: p.initial, Received: sum(p,'RECEIVED'), Adjust: sum(p,'adjust'), Picking: sum(p,'picking'), Amsped: sum(p,'amsped'), B2B: sum(p,'b2b'), RealStock: calculateStock(p,'real',logs), ToConfirm: p.toConfirm }));
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(summary), "Summary");
        const moves = []; products.forEach(p => p.movements.forEach(m => moves.push({ Produto: p.sku, Date: m.date, Type: m.type, Qty: m.qty, Note: m.note||'' })));
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(moves), "All Movements");
        XLSX.writeFile(wb, `Inventory_Report_${currentMonth}.xlsx`);
    }

    async function exportAllDataXLSX(){
        if (!window.fb) return alert('Firebase not ready.');
        if (userRole === 'pl') return alert('A conta .pl √© apenas leitura.');

        const wb = XLSX.utils.book_new();

        // 1) Warehouse master
        try{
            const wh = await window.fb.getDocData(['meta','warehouse']);
            const items = (wh && Array.isArray(wh.items)) ? wh.items : [];
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(items), 'Warehouse_Master');
        }catch(e){}

        // 2) All months
        const ids = await window.fb.listDocIds('months');
        const monthIds = (ids || []).sort((a,b)=>String(a).localeCompare(String(b)));

        const allMovements = [];
        const allLogs = [];

        for (const mid of monthIds){
            const d = await window.fb.getDocData(['months', mid]);
            if (!d) continue;

            const prods = d.products || [];
            const logsArr = d.logs || [];

            const summary = prods.map(p => ({
                month: mid,
                Produto: p.sku,
                Initial: Number(p.initial||0),
                Received: (p.movements||[]).filter(m=>m.type==='RECEIVED').reduce((a,c)=>a+Number(c.qty||0),0),
                Adjust:   (p.movements||[]).filter(m=>m.type==='adjust').reduce((a,c)=>a+Number(c.qty||0),0),
                Picking:  (p.movements||[]).filter(m=>m.type==='picking').reduce((a,c)=>a+Number(c.qty||0),0),
                Amsped:   (p.movements||[]).filter(m=>m.type==='amsped').reduce((a,c)=>a+Number(c.qty||0),0),
                B2B:      (p.movements||[]).filter(m=>m.type==='b2b').reduce((a,c)=>a+Number(c.qty||0),0),
                ToConfirm: Number(p.toConfirm||0),
            }));

            prods.forEach(p => {
                (p.movements||[]).forEach(m => {
                    allMovements.push({
                        month: mid,
                        date: m.date || '',
                        produto: p.sku,
                        type: m.type || '',
                        qty: Number(m.qty||0),
                        note: m.note || '',
                        by: m.by || '',
                        uid: m.uid || ''
                    });
                });
            });

            logsArr.forEach(l => {
                allLogs.push({
                    month: mid,
                    date: l.date || '',
                    arrivalDate: l.arrivalDate || '',
                    sku: l.sku || '',
                    status: l.status || '',
                    qty: Number(l.qty||0),
                    receivedQty: Number(l.receivedQty||0),
                    note: l.note || '',
                    by: l.by || '',
                    uid: l.uid || '',
                    sourceMonth: l.sourceMonth || '',
                    sourceId: l.sourceId || ''
                });
            });

            const safeName = ('M_' + mid).replace(/[^A-Za-z0-9_]/g,'_');
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(summary), safeName + '_Summary');
        }

        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(allLogs), 'ALL_Logs');
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(allMovements), 'ALL_Movements');

        XLSX.writeFile(wb, `Inventory_ALL_DATA_${new Date().toISOString().slice(0,10)}.xlsx`);
    }


    async function getAllMonthIdsSorted(){
        const ids = await window.fb.listDocIds('months'); // ["YYYY-MM", ...]
        return (ids || []).sort((a,b)=>String(a).localeCompare(String(b)));
    }

    async function getMonthDoc(monthId){
        try { return await window.fb.getDocData(['months', monthId]); } catch(e){ return null; }
    }

    async function getMonthsForMode(){
        const mode = document.getElementById('analyticsMode')?.value || 'month';

        if (mode === 'month') {
            const mid = document.getElementById('analyticsMonth')?.value || currentMonth;
            const data = allData[mid] || await getMonthDoc(mid);
            return [{ id: mid, data }];
        }

        const ids = await getAllMonthIdsSorted();

        if (mode === 'year') {
            const y = document.getElementById('analyticsYear')?.value || String(new Date().getFullYear());
            const yearIds = ids.filter(m => String(m).startsWith(y + '-'));
            const out = [];
            for (const mid of yearIds){
                const d = await getMonthDoc(mid);
                if (d) out.push({ id: mid, data: d });
            }
            return out;
        }

        // mode === 'all'
        const out = [];
        for (const mid of ids){
            const d = await getMonthDoc(mid);
            if (d) out.push({ id: mid, data: d });
        }
        return out;
    }

    function sumMovementsFromMonthDoc(monthDoc, movementType){
        const prods = monthDoc?.products || [];
        let total = 0;
        prods.forEach(p => {
            (p.movements || []).forEach(m => {
                if (m?.type === movementType) total += Number(m.qty || 0);
            });
        });
        return total;
    }

    function rankSkuAcrossMonths(monthDocs, movementType, topN=5){
        const acc = new Map(); // sku -> qty
        monthDocs.forEach(({data}) => {
            (data?.products || []).forEach(p => {
                let q = 0;
                (p.movements || []).forEach(m => { if (m?.type === movementType) q += Number(m.qty||0); });
                if (q > 0) acc.set(p.sku, (acc.get(p.sku)||0) + q);
            });
        });
        return Array.from(acc.entries())
            .map(([sku,q])=>({sku,q}))
            .sort((a,b)=>b.q-a.q)
            .slice(0, topN);
    }

    async function ensureAnalyticsYearOptions(){
        const sel = document.getElementById('analyticsYear');
        if (!sel) return;
        const ids = await getAllMonthIdsSorted();
        const years = Array.from(new Set((ids || []).map(m => String(m).slice(0,4)))).sort();
        const curY = String(new Date().getFullYear());
        sel.innerHTML = years.map(y => `<option value="${y}">${y}</option>`).join('');
        sel.value = years.includes(curY) ? curY : (years[years.length-1] || curY);
    }

    async function ensureAnalyticsMonthOptions(){
        const sel = document.getElementById('analyticsMonth');
        if (!sel) return;

        // Preserve user selection before repopulating options
        const prev = sel.value;

        const ids = await getAllMonthIdsSorted();
        sel.innerHTML = (ids || []).map(m => `<option value="${m}">${m}</option>`).join('');

        const wanted = prev || currentMonth;
        if ((ids || []).includes(wanted)) sel.value = wanted;
        else if ((ids || []).includes(currentMonth)) sel.value = currentMonth;
        else sel.value = (ids && ids.length) ? ids[ids.length-1] : currentMonth;
    }

    async function exportAnalyticsCSV(){
        try{
            if (!window.fb) return alert('Firebase not ready.');

            const mode = document.getElementById('analyticsMode')?.value || 'month';
            if (mode === 'month') await ensureAnalyticsMonthOptions();
            if (mode === 'year') await ensureAnalyticsYearOptions();

            const months = await getMonthsForMode(); // [{id,data}]
            const periodLabel =
                (mode === 'month') ? (months[0]?.id || '') :
                (mode === 'year') ? (document.getElementById('analyticsYear')?.value || '') :
                'ALL';

            // Dataset 1: picking series (daily for month, monthly otherwise)
            const pickingRows = [];
            if (mode === 'month') {
                const monthId = months[0]?.id;
                const monthDoc = months[0]?.data || { products: [] };
                const days = Array.from({length: 31}, (_, i) => String(i + 1).padStart(2, '0'));
                days.forEach(d => {
                    const ds = `${monthId}-${d}`;
                    const qty = (monthDoc.products || []).reduce((acc, p) => {
                        const v = (p.movements || []).filter(m => m.date === ds && m.type === 'picking')
                            .reduce((a,c)=>a + Number(c.qty||0), 0);
                        return acc + v;
                    }, 0);
                    pickingRows.push({ dataset: 'picking_series', period: periodLabel, label: ds, qty });
                });
            } else {
                months.forEach(({id,data}) => {
                    const qty = sumMovementsFromMonthDoc(data, 'picking');
                    pickingRows.push({ dataset: 'picking_series', period: periodLabel, label: id, qty });
                });
            }

            // Dataset 2/3: top sold + returns (top 50 for export)
            const topSold = rankSkuAcrossMonths(months, 'amsped', 50).map(x => ({
                dataset: 'top_sold_amsped', period: periodLabel, sku: x.sku, qty: x.q
            }));
            const topReturns = rankSkuAcrossMonths(months, 'returns', 50).map(x => ({
                dataset: 'top_returns', period: periodLabel, sku: x.sku, qty: x.q
            }));

            // Dataset 4: Procurement coverage (ALL SKUs)
            const acc = new Map(); // normSku -> {sku, ordered, sent, received}
            months.forEach(({data}) => {
                const logsArr = data?.logs || [];
                const prods = data?.products || [];

                logsArr.forEach(l => {
                    const sku = l?.sku || '';
                    if (!sku) return;
                    const k = normKey(sku);
                    if (!acc.has(k)) acc.set(k, { sku, ordered:0, sent:0, received:0 });
                    const row = acc.get(k);
                    if (l.status === 'ORDER') row.ordered += Number(l.qty||0);
                    if (l.status === 'SENT')  row.sent    += Number(l.qty||0);
                });

                prods.forEach(p => {
                    const k = normKey(p.sku);
                    if (!acc.has(k)) acc.set(k, { sku: p.sku, ordered:0, sent:0, received:0 });
                    const row = acc.get(k);
                    row.received += (p.movements || []).filter(m => m.type === 'RECEIVED')
                        .reduce((a,c)=>a + Number(c.qty||0), 0);
                });
            });

            const procurementRows = Array.from(acc.values()).map(r => {
                const ordered = Number(r.ordered||0);
                const sent = Number(r.sent||0);
                const received = Number(r.received||0);
                const gap = ordered - (sent + received);
                return { dataset: 'procurement_coverage', period: periodLabel, sku: r.sku, ordered, sent, received, gap };
            }).sort((a,b)=> b.gap - a.gap);

            const rows = [...pickingRows, ...topSold, ...topReturns, ...procurementRows];

            const csv = Papa.unparse(rows, { quotes: true });
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Analytics_${mode}_${periodLabel}_${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        } catch(e){
            console.error(e);
            alert('Falha ao exportar Analytics CSV.');
        }
    }

    async function renderAnalytics() {
        Object.values(charts).forEach(c => { if(c) c.destroy(); });
        if (!window.fb) return;

        const mode = document.getElementById('analyticsMode')?.value || 'month';

        // UI: month selector is independent from top picker
        const monthWrap = document.getElementById('analyticsMonthWrap');
        const yearWrap = document.getElementById('analyticsYearWrap');
        if (monthWrap) monthWrap.style.display = (mode === 'month') ? 'block' : 'none';
        if (yearWrap) yearWrap.style.display = (mode === 'year') ? 'block' : 'none';
        if (mode === 'month') await ensureAnalyticsMonthOptions();
        if (mode !== 'month') await ensureAnalyticsYearOptions();

        const months = await getMonthsForMode(); // [{id,data}]
        const monthDoc = months[0]?.data || { products: [], logs: [] };

        // Keep legacy globals consistent for other UI parts if needed
        products = monthDoc.products || [];
        logs = monthDoc.logs || [];

        // --- Chart 1: Picking activity ---
        if (mode === 'month') {
            const days = Array.from({length: 31}, (_, i) => String(i + 1).padStart(2, '0'));
            const pickingData = days.map(d => {
                const ds = `${months[0].id}-${d}`;
                return (products || []).reduce((acc, p) =>
                    acc + (p.movements || []).filter(m => m.date === ds && m.type === 'picking').reduce((a,c)=>a+Number(c.qty||0),0),
                0);
            });

            charts.daily = new Chart(document.getElementById('dailyChart'), {
                type: 'line',
                data: { labels: days, datasets: [{ label: 'Picking Activity', data: pickingData, borderColor: '#007bff', fill: true }] },
                options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
            });
        } else {
            const labels = months.map(x => x.id);
            const pickingByMonth = months.map(x => sumMovementsFromMonthDoc(x.data, 'picking'));

            charts.daily = new Chart(document.getElementById('dailyChart'), {
                type: 'bar',
                data: { labels, datasets: [{ label: 'Picking (total por m√™s)', data: pickingByMonth }] },
                options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } }
            });
        }

        // --- Charts 2 & 3: Top Sold + Returns (agregado no per√≠odo) ---
        const topSold = rankSkuAcrossMonths(months, 'amsped', 5);
        charts.top = new Chart(document.getElementById('topSoldChart'), {
            type: 'bar',
            data: { labels: topSold.map(d => d.sku), datasets: [{ label: 'Sales', data: topSold.map(d => d.q), backgroundColor: '#2ecc71' }] },
            options: { indexAxis: 'y', maintainAspectRatio: false }
        });

        const topReturns = rankSkuAcrossMonths(months, 'returns', 5);
        charts.ret = new Chart(document.getElementById('returnsChart'), {
            type: 'bar',
            data: { labels: topReturns.map(d => d.sku), datasets: [{ label: 'Returns', data: topReturns.map(d => d.q), backgroundColor: '#e74c3c' }] },
            options: { indexAxis: 'y', maintainAspectRatio: false }
        });

        // --- Procurement Coverage (ORDER vs SENT vs RECEIVED) ---
        const body = document.getElementById('bodyDiscrepancies');
        if (body) body.innerHTML = '';

        const acc = new Map(); // normSku -> {sku, ordered, sent, received}

        months.forEach(({data}) => {
            const logsArr = data?.logs || [];
            const prods = data?.products || [];

            // ORDER / SENT from logs
            logsArr.forEach(l => {
                const sku = l?.sku || '';
                if (!sku) return;
                const k = normKey(sku);
                if (!acc.has(k)) acc.set(k, { sku, ordered:0, sent:0, received:0 });
                const row = acc.get(k);
                if (l.status === 'ORDER') row.ordered += Number(l.qty||0);
                if (l.status === 'SENT')  row.sent    += Number(l.qty||0);
            });

            // RECEIVED from movements
            prods.forEach(p => {
                const k = normKey(p.sku);
                if (!acc.has(k)) acc.set(k, { sku: p.sku, ordered:0, sent:0, received:0 });
                const row = acc.get(k);
                row.received += (p.movements || []).filter(m => m.type === 'RECEIVED')
                    .reduce((a,c)=>a + Number(c.qty||0), 0);
            });
        });

        const rows = Array.from(acc.values())
            .map(r => {
                const ordered = Number(r.ordered||0);
                const sent = Number(r.sent||0);
                const received = Number(r.received||0);
                const gap = ordered - (sent + received);
                return { sku: r.sku, ordered, sent, received, gap };
            })
            .filter(r => r.gap > 0)
            .sort((a,b) => b.gap - a.gap);

        if (body) {
            rows.forEach(r => {
                body.innerHTML += `<tr>
                    <td>${r.sku}</td>
                    <td>${r.ordered}</td>
                    <td>${r.sent}</td>
                    <td>${r.received}</td>
                    <td style="color:red;font-weight:bold">${r.gap}</td>
                </tr>`;
            });
        }

    }

    function openTab(id) {
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        event.currentTarget.classList.add('active');
        if(id === 'analytics') setTimeout(async () => { await ensureAnalyticsYearOptions(); await ensureAnalyticsMonthOptions(); renderAnalytics(); }, 50); else renderAll();
    }

    function setDates() {
        const t = new Date().toISOString().split('T')[0];
        let y = new Date(); y.setDate(y.getDate()-1); 
        document.querySelectorAll('.today-date').forEach(el => el.value = t);
        document.querySelectorAll('.yesterday-date').forEach(el => el.value = y.toISOString().split('T')[0]);
    }

    function addSingle(type) {
        const k = type.charAt(0).toUpperCase() + type.slice(1);
        const s = document.getElementById(`single${k}Sku`).value.trim(), q = parseInt(document.getElementById(`single${k}Qty`).value), d = document.getElementById(`date${k}`).value;
        const p = findProd(s);
        if(p && !isNaN(q)) { p.movements.push({ type, qty: (type==='adjust'?q:Math.abs(q)), date: d, note: document.getElementById(`single${k}Note`)?.value || '' }); save(); flushSaveMonth(); renderAll(); document.getElementById(`single${k}Sku`).value=""; }
    }

    function processBulk(type) {
        const k = type.charAt(0).toUpperCase() + type.slice(1);
        const text = document.getElementById('input' + k).value.trim(), date = document.getElementById('date' + k).value;
        text.split('\n').forEach(line => {
            const parsed = parseBulkLine(line); if(!parsed) return;
            const { sku, qty } = parsed;
            const prod = findProd(sku);
            if(prod) prod.movements.push({ type, qty: (type==='adjust'?qty:Math.abs(qty)), date, by: currentActorEmail(), uid: currentActorUid() });
        });
        save(); flushSaveMonth(); renderAll(); document.getElementById('input' + k).value = "";
    }

    function addSingleFromSelect(id) {
        const t = document.getElementById('type'+id).value, s = document.getElementById('single'+id+'Sku').value.trim(), q = parseInt(document.getElementById('single'+id+'Qty').value), d = document.getElementById('date'+id).value;
        const p = findProd(s); if(p&&!isNaN(q)) { p.movements.push({type:t, qty:Math.abs(q), date:d, by: currentActorEmail(), uid: currentActorUid() }); save(); flushSaveMonth(); renderAll(); document.getElementById('single'+id+'Sku').value=""; }
    }


function processBulkFromSelect(id) {
    // For tabs that have a type <select> (e.g., Returns): apply the selected type to all bulk lines.
    const t = document.getElementById('type'+id).value;
    const textEl = document.getElementById('input'+id);
    const dateEl = document.getElementById('date'+id);
    if(!textEl || !dateEl) return;
    const text = (textEl.value || '').trim();
    const d = dateEl.value;
    if(!text) return;

    text.split('\n').forEach(line => {
        const parsed = parseBulkLine(line); if(!parsed) return;
        const { sku, qty } = parsed;
        const p = findProd(sku);
        if(p) p.movements.push({ type: t, qty: Math.abs(qty), date: d, by: currentActorEmail(), uid: currentActorUid() });
    });

    save(); flushSaveMonth(); renderAll();
    textEl.value = "";
}


    function showHistory(i) {
        const p = products[i], b = document.getElementById('histBody'); b.innerHTML = '';
        p.movements.forEach((m, mi) => b.innerHTML += `<tr><td>${m.date}</td><td>${m.type}</td><td>${m.qty}</td><td>${m.note||''}</td><td><button class="btn btn-danger" onclick="products[${i}].movements.splice(${mi},1);save();showHistory(${i});renderAll()">X</button></td></tr>`);
        document.getElementById('historyModal').style.display = 'block';
    }

    function renderMiniDash() {
        const pick = products.reduce((a,p)=>a+sum(p,'picking'),0), sales = products.reduce((a,p)=>a+sum(p,'amsped'),0), rec = products.reduce((a,p)=>a+sum(p,'RECEIVED'),0);
        document.getElementById('dash-general').innerHTML = `<div class="stat-card"><h4>Received</h4><div class="value">${rec}</div></div><div class="stat-card"><h4>Transit</h4><div class="value" style="color:#000">${logs.filter(l=>l.status==='SENT').reduce((a,c)=>a+c.qty,0)}</div></div>`;
    }

    function filterTable(tid, sid) { const q = document.getElementById(sid).value.toLowerCase(); document.querySelectorAll(`#${tid} tr`).forEach(r => r.style.display = r.innerText.toLowerCase().includes(q) ? '' : 'none'); }
    function deleteLog(i) { logs.splice(i,1); save(); flushSaveMonth(); renderAll(); }
    function deleteMove(pi, mi) { products[pi].movements.splice(mi,1); save(); flushSaveMonth(); renderAll(); }

    // Movements tab: delete (keeps Orders&Shipments logs and RECEIVED movements consistent)
    function deleteLogAndLinkedMovement(li) {
        const log = (logs || [])[li];
        if (!log) return;
        const logId = log.id;
        // remove linked RECEIVED movement(s)
        if (logId) {
            products.forEach(p => {
                const idx = (p.movements || []).findIndex(m => m && m.logId === logId);
                if (idx >= 0) p.movements.splice(idx, 1);
            });
        }
        logs.splice(li, 1);
        save(); flushSaveMonth(); renderAll();
    }

    function deleteMoveAndLinkedLog(pi, mi) {
        const p = products[pi];
        const mv = p?.movements?.[mi];
        if (!p || !mv) return;
        const logId = mv.logId;
        p.movements.splice(mi, 1);

        if (logId) {
            const li = (logs || []).findIndex(l => l && l.id === logId);
            if (li >= 0) logs.splice(li, 1);
        }
        save(); flushSaveMonth(); renderAll();
    }

    // key format: M:<productIndex>:<movementIndex> OR L:<logIndex>
    window.deleteMovementByKey = function(key) {
        try {
            if (!key) return;
            if (!confirm('Apagar este movimento?')) return;
            const [kind, a, b] = key.split(':');
            if (kind === 'M') {
                const pi = Number(a), mi = Number(b);
                if (Number.isFinite(pi) && Number.isFinite(mi)) deleteMoveAndLinkedLog(pi, mi);
            } else if (kind === 'L') {
                const li = Number(a);
                if (Number.isFinite(li)) deleteLogAndLinkedMovement(li);
            }
        } catch (e) {
            console.error('deleteMovementByKey failed', e);
            alert('Erro ao apagar movimento. V√™ a consola.');
        }
    };

    // Movements tab: delete (keeps Orders&Shipments logs and RECEIVED movements consistent)
    function deleteLogAndLinkedMovement(li) {
        const log = (logs || [])[li];
        if (!log) return;
        const logId = log.id;
        // remove linked RECEIVED movement(s)
        if (logId) {
            products.forEach(p => {
                const idx = (p.movements || []).findIndex(m => m && m.logId === logId);
                if (idx >= 0) p.movements.splice(idx, 1);
            });
        }
        logs.splice(li, 1);
        save(); flushSaveMonth(); renderAll();
    }

    function deleteMoveAndLinkedLog(pi, mi) {
        const p = products[pi];
        const mv = p?.movements?.[mi];
        if (!p || !mv) return;
        const logId = mv.logId;
        p.movements.splice(mi, 1);

        if (logId) {
            const li = (logs || []).findIndex(l => l && l.id === logId);
            if (li >= 0) logs.splice(li, 1);
        }
        save(); flushSaveMonth(); renderAll();
    }

    // key format: M:<productIndex>:<movementIndex> OR L:<logIndex>
    window.deleteMovementByKey = function(key) {
        try {
            if (!key) return;
            if (!confirm('Apagar este movimento?')) return;
            const [kind, a, b] = key.split(':');
            if (kind === 'M') {
                const pi = Number(a), mi = Number(b);
                if (Number.isFinite(pi) && Number.isFinite(mi)) deleteMoveAndLinkedLog(pi, mi);
            } else if (kind === 'L') {
                const li = Number(a);
                if (Number.isFinite(li)) deleteLogAndLinkedMovement(li);
            }
        } catch (e) {
            console.error('deleteMovementByKey failed', e);
            alert('Erro ao apagar movimento. V√™ a consola.');
        }
    };
    function closeModal() { document.getElementById('historyModal').style.display='none'; }
    function resetMonth() { if(confirm("WIPE MONTH?")) { products.forEach(p => p.movements = []); logs=[]; save(); flushSaveMonth(); renderAll(); } }
    function addNewProductMaster() {
        const prod = (prompt("Produto:") || '').toString().trim();
        if (!prod) return;

        // Add to Warehouse master list (so it becomes available everywhere)
        const exists = (warehouseItems || []).some(r => (r?.produto || '').toString().trim() === prod);
        if (!exists) {
            warehouseItems.push({ produto: prod, posicao: '', dimensoes: '', peso: '', volume: '' });
            saveWarehouse();
        }

        // Re-load month data to reconcile products with the updated master list
        if (currentMonth && allData[currentMonth]) {
            loadMonthData();
        } else {
            renderWarehouse(); renderMovements();
            alert('Produto adicionado ao Warehouse. Escolhe/inicializa um m√™s para come√ßar.');
        }
    }


    /* =========================
       WAREHOUSE MASTER (Upload + Editable Table)
       Columns expected:
       A Produto | B Posi√ß√£o | C Dimens√µes | D Peso | E Volume
    ========================== */

    function saveWarehouse() {
        // Firestore save (warehouse master)
        if (!window.fb) return;
        if (userRole === 'pl') return; // PL is read-only
        window.fb.setDocData(['meta', 'warehouse'], { items: warehouseItems || [], updatedAt: new Date().toISOString() })
            .catch(e => console.error('Warehouse save failed', e));
    }

    async function loadWarehouseFromFirestore() {
        if (!window.fb) return;
        const data = await window.fb.getDocData(['meta', 'warehouse']);
        warehouseItems = (data && Array.isArray(data.items)) ? data.items : [];
    }

function normalizeHeader(h) {
        return (h || '').toString().trim().toLowerCase()
            .replace(/\s+/g,' ')
            .replace(/√ß/g,'c')
            .normalize('NFD').replace(/[\u0300-\u036f]/g,''); // remove accents
    }

    

    // --- Volume auto-calc from Dimens√µes (C*L*A) ---
    function parseDimNumbers(dimStr) {
        const s = (dimStr || '').toString().trim();
        const m = s.match(/(\d+(?:[\.,]\d+)?)/g);
        if (!m || m.length < 3) return null;
        const nums = m.slice(0, 3).map(x => parseFloat(x.replace(',', '.')));
        if (nums.some(n => Number.isNaN(n))) return null;
        return nums;
    }
    function formatNumberPT(n) {
        if (n == null || Number.isNaN(n)) return '';
        const isInt = Math.abs(n - Math.round(n)) < 1e-9;
        let s = isInt ? String(Math.round(n)) : n.toFixed(2).replace(/\.?0+$/, '');
        return s.replace('.', ',');
    }
    function computeVolumeFromDim(dimStr) {
        const nums = parseDimNumbers(dimStr);
        if (!nums) return '';
        const vol = nums[0] * nums[1] * nums[2];
        return formatNumberPT(vol);
    }

function mapRowToWarehouse(row) {
        const dimensoes = (row[2] ?? '').toString().trim();
        return {
            produto: (row[0] ?? '').toString().trim(),
            posicao: (row[1] ?? '').toString().trim(),
            dimensoes,
            peso: (row[3] ?? '').toString().trim(),
            // Column E (volume) is ignored; we compute it from Dimens√µes
            volume: computeVolumeFromDim(dimensoes),
        };
    }
function renderWarehouse() {
        const body = document.getElementById('bodyWarehouse');
        if (!body) return; // safety for older saved pages
        body.innerHTML = '';

        let changed = false;

        warehouseItems.forEach((it, idx) => {
            // Keep volume consistent with Dimens√µes (auto)
            const autoVol = computeVolumeFromDim(it.dimensoes);
            if ((it.volume || '') !== autoVol) { it.volume = autoVol; changed = true; }

            const tr = document.createElement('tr');

            const mkInput = (value, field, opts = {}) => {
                const td = document.createElement('td');
                const inp = document.createElement('input');
                inp.value = value || '';
                inp.className = 'input';
                inp.style.width = '100%';
                if (opts.readonly) {
                    inp.readOnly = true;
                    inp.style.background = '#f5f5f5';
                }
                inp.onchange = () => {
                    if (!opts.readonly) {
                        warehouseItems[idx][field] = inp.value;
                        saveWarehouse();
                        if (field === 'produto') {
                            // Keep Management/Month product lists synced with the master list
                            syncProductsFromWarehouse();
                            renderManagement();
                            updateDatalist();
                        }
                    }
                    if (opts.onchange) opts.onchange(inp.value);
                };
                td.appendChild(inp);
                return { td, inp };
            };

            const prod = mkInput(it.produto, 'produto');
            const pos  = mkInput(it.posicao, 'posicao');
            const peso = mkInput(it.peso, 'peso');

            // Volume input (readonly, computed)
            const vol  = mkInput(it.volume, 'volume', { readonly: true });

            // Dimens√µes input updates volume automatically
            const dim  = mkInput(it.dimensoes, 'dimensoes', {
                onchange: (v) => {
                    warehouseItems[idx].dimensoes = v;
                    const vAuto = computeVolumeFromDim(v);
                    warehouseItems[idx].volume = vAuto;
                    vol.inp.value = vAuto;
                    saveWarehouse();
                }
            });

            tr.appendChild(prod.td);
            tr.appendChild(pos.td);
            tr.appendChild(dim.td);
            tr.appendChild(peso.td);
            tr.appendChild(vol.td);

            const tdAct = document.createElement('td');
            tdAct.innerHTML = `<button class="btn btn-danger" onclick="deleteWarehouseRow(${idx})">üóëÔ∏è</button>`;
            tr.appendChild(tdAct);

            body.appendChild(tr);
        });

        if (changed) saveWarehouse();
    }


function addWarehouseRow() {
        warehouseItems.unshift({ produto:'', posicao:'', dimensoes:'', peso:'', volume:'' });
        saveWarehouse();
        renderWarehouse(); renderMovements();
        syncProductsFromWarehouse();
        syncProductsFromWarehouse();
    }

    function deleteWarehouseRow(idx) {
        if (!confirm('Delete this row?')) return;
        warehouseItems.splice(idx, 1);
        saveWarehouse();
        renderWarehouse(); renderMovements();
        syncProductsFromWarehouse();
        syncProductsFromWarehouse();
    }

    function clearWarehouse() {
        if (!confirm('Clear ALL warehouse rows?')) return;
        warehouseItems = [];
        saveWarehouse();
        renderWarehouse(); renderMovements();
        syncProductsFromWarehouse();
        syncProductsFromWarehouse();
    syncProductsFromWarehouse();
    }

    function importWarehouseFile() {
        const input = document.getElementById('warehouseFile');
        const file = input?.files?.[0];
        if (!file) { alert('Select a CSV/XLSX file first.'); return; }

        const name = file.name.toLowerCase();
        if (name.endsWith('.xlsx') || name.endsWith('.xls')) return importWarehouseXLSX(file);
        return importWarehouseCSV(file);
    }

    function importWarehouseCSV(file) {
        if (typeof Papa === 'undefined') {
            alert('PapaParse not loaded. Check your internet connection or include the library.');
            return;
        }

        Papa.parse(file, {
            skipEmptyLines: true,
            complete: (res) => {
                const data = res.data || [];
                if (!data.length) { alert('CSV empty.'); return; }

                // detect header row
                const first = data[0];
                const looksHeader = first.some(c => {
                    const h = normalizeHeader(c);
                    return ['produto','product','products picking','position','posicao','dimensoes','dimensoes c*l*a','peso','weight','volume'].includes(h);
                });

                let rows = data;
                if (looksHeader) rows = data.slice(1);

                const parsed = rows
                    .map(r => mapRowToWarehouse(r))
                    .filter(r => Object.values(r).some(v => v && v.trim() !== ''));

                warehouseItems = parsed;
                saveWarehouse();
                renderWarehouse(); renderMovements();
                alert(`Imported ${warehouseItems.length} rows.`);
            syncProductsFromWarehouse();
            },
            error: (err) => alert('CSV parse error: ' + err.message)
        });
    }

    function importWarehouseXLSX(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const data = new Uint8Array(e.target.result);
            const wb = XLSX.read(data, { type: 'array' });
            const sheet = wb.Sheets[wb.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });

            if (!rows.length) { alert('XLSX empty.'); return; }

            const first = rows[0];
            const looksHeader = first.some(c => {
                const h = normalizeHeader(c);
                return ['produto','product','products picking','position','posicao','dimensoes','dimensoes c*l*a','peso','weight','volume'].includes(h);
            });

            const dataRows = looksHeader ? rows.slice(1) : rows;

            const parsed = dataRows
                .map(r => mapRowToWarehouse(r))
                .filter(r => Object.values(r).some(v => v && v.toString().trim() !== ''));

            warehouseItems = parsed;
            saveWarehouse();
            renderWarehouse(); renderMovements();
            alert(`Imported ${warehouseItems.length} rows.`);
            syncProductsFromWarehouse();
        };
        reader.readAsArrayBuffer(file);
    }

    

    
    // --- MANAGEMENT: Bulk import initial quantities (Produto, Quantidade) ---
    function detectInitHeaderRow(row) {
        if (!row) return false;
        return row.some(c => {
            const h = normalizeHeader(c);
            return ['produto','product','item','artigo'].includes(h) || ['quantidade','quantity','qty','qtd','stock'].includes(h);
        });
    }

    function applyInitQtyRows(rows) {
        if (!rows || !rows.length) { alert('No rows found.'); return; }

        // Ensure every product in the file exists in the Warehouse master (auto-add if missing)
        const fileProds = rows
            .map(r => (r[0] ?? '').toString().trim())
            .filter(Boolean);

        let changedMaster = false;
        fileProds.forEach(prod => {
            const exists = (warehouseItems || []).some(w =>
                (w?.produto || '').toString().trim().toLowerCase() === prod.toLowerCase()
            );
            if (!exists) {
                warehouseItems.push({ produto: prod, posicao: '', dimensoes: '', peso: '', volume: '' });
                changedMaster = true;
            }
        });

        if (changedMaster) {
            saveWarehouse();
            // Make sure product lists (Management + current month) include the new products
            syncProductsFromWarehouse();
            renderWarehouse();
        }

        // Build index of products by normalized name (produto)
        const idx = new Map();
        products.forEach((p, i) => {
            const key = String(p.sku || '').trim().toLowerCase();
            if (key) idx.set(key, i);
        });

        // Reset all initial quantities to 0 before applying (so the file becomes the source of truth)
        products.forEach(p => { p.initial = 0; });

        let applied = 0;
        const stillMissing = [];

        rows.forEach(r => {
            const prod = (r[0] ?? '').toString().trim();
            if (!prod) return;

            const rawQty = (r[1] ?? '').toString().trim();
            const num = Number(rawQty.replace(',', '.'));
            const qty = isNaN(num) ? 0 : Math.round(num);

            const key = prod.toLowerCase();
            if (idx.has(key)) {
                products[idx.get(key)].initial = qty;
                applied++;
            } else {
                // In case of weird whitespace/encoding mismatch
                stillMissing.push(prod);
            }
        });

        save(); flushSaveMonth(); renderAll();

        let msg = `Imported initial quantities for ${applied} products.`;
        if (changedMaster) msg += `
Added ${fileProds.length - (fileProds.length - (warehouseItems||[]).length)} new products to Warehouse master (auto-sync).`;
        if (stillMissing.length) {
            msg += `
Still not matched (${stillMissing.length}): ${stillMissing.slice(0, 20).join(', ')}${stillMissing.length > 20 ? '...' : ''}`;
        }
        alert(msg);
    }

    function importInitQtyCSV(file) {
        Papa.parse(file, {
            skipEmptyLines: true,
            complete: (res) => {
                const data = res.data || [];
                if (!data.length) { alert('CSV empty.'); return; }
                const looksHeader = detectInitHeaderRow(data[0]);
                const rows = looksHeader ? data.slice(1) : data;
                applyInitQtyRows(rows);
            },
            error: (err) => alert('CSV parse error: ' + err.message)
        });
    }

    function importInitQtyXLSX(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const data = new Uint8Array(e.target.result);
            const wb = XLSX.read(data, { type: 'array' });
            const sheet = wb.Sheets[wb.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
            if (!rows.length) { alert('XLSX empty.'); return; }
            const looksHeader = detectInitHeaderRow(rows[0]);
            const dataRows = looksHeader ? rows.slice(1) : rows;
            applyInitQtyRows(dataRows);
        };
        reader.readAsArrayBuffer(file);
    }

    function importInitQtyFile() {
        const input = document.getElementById('mgmtInitUpload');
        const file = input && input.files ? input.files[0] : null;
        if (!file) { alert('Choose a CSV or XLSX file first.'); return; }

        const name = (file.name || '').toLowerCase();
        if (name.endsWith('.csv')) return importInitQtyCSV(file);
        if (name.endsWith('.xlsx') || name.endsWith('.xls')) return importInitQtyXLSX(file);

        alert('Unsupported file type. Please upload CSV or XLSX.');
    }


// --- MOVEMENTS (all tabs) ---
    function mapMovementToTab(type) {
        const map = {
            'adjust': 'Adjustments',
            'returns': 'Returns',
            'recovered': 'Returns',
            'refunds': 'Returns',
            'customerCare': 'Internal & Care',
            'awards': 'Internal & Care',
            'officeNeeds': 'Internal & Care',
            'picking': 'Picking Out',
            'amsped': 'Amsped Sales',
            'b2b': 'B2B',
            'RECEIVED': 'Orders & Shipments'
        };
        return map[type] || 'Other';
    }

    function getAllMovementsBase() {
        let rows = [];

        // Product movements (from all operational tabs)
        products.forEach((p, pi) => {
            (p.movements || []).forEach((m, mi) => {
                const date = m.date || '';
                const produto = p.sku;
                const tab = mapMovementToTab(m.type);
                const tipo = m.type;
                const qty = m.qty ?? 0;
                const note = m.note || '';
                rows.push({ date, month: currentMonth, produto, tab, tipo, qty, note, by: m.by || '', uid: m.uid || '', _src: 'MOVE', _pi: pi, _mi: mi, _key: `M:${pi}:${mi}` });
            });
        });

        // Orders & Shipments logs (ORDER / SHIP / RECEIVED)
        (logs || []).forEach((l, li) => {
            const date = l.arrivalDate || l.date || '';
            const produto = l.sku || '';
            const tab = 'Orders & Shipments';
            const tipo = l.status || '';
            const qty = (l.status === 'RECEIVED') ? (l.receivedQty ?? l.qty ?? 0) : (l.qty ?? 0);
            const note = l.status === 'RECEIVED' ? 'Arrival: ' + (l.arrivalDate || '') : '';
            rows.push({ date, month: currentMonth, produto, tab, tipo, qty, note, by: l.by || '', uid: l.uid || '', _src: 'LOG', _li: li, _key: `L:${li}` });
        });

        // sort
        rows.sort((a,b) => (a.date||'').localeCompare(b.date||'') || (a.produto||'').localeCompare(b.produto||''));
        return rows;
    }

    function ensureMovTabOptions() {
        const sel = document.getElementById('movTab');
        if (!sel) return;
        const current = sel.value || 'all';
        const tabs = Array.from(new Set(getAllMovementsBase().map(r => r.tab).filter(Boolean)))
            .sort((a,b)=>a.localeCompare(b));
        sel.innerHTML = `<option value="all">All</option>` + tabs.map(t => {
            const safe = (t || '').toString().replace(/"/g, '&quot;');
            return `<option value="${safe}">${t}</option>`;
        }).join('');
        sel.value = tabs.includes(current) ? current : 'all';
    }

    function getAllMovementsFiltered() {
        const from = document.getElementById('movFrom')?.value || '';
        const to = document.getElementById('movTo')?.value || '';
        const q = (document.getElementById('movSearch')?.value || '').trim().toLowerCase();
        const tabFilter = document.getElementById('movTab')?.value || 'all';

        let rows = getAllMovementsBase();

        // filters
        if (from) rows = rows.filter(r => r.date && r.date >= from);
        if (to) rows = rows.filter(r => r.date && r.date <= to);
        if (q) rows = rows.filter(r => (r.produto || '').toLowerCase().includes(q));
        if (tabFilter && tabFilter !== 'all') rows = rows.filter(r => r.tab === tabFilter);

        return rows;
    }

    function renderMovements() {
        ensureMovTabOptions();
        const head = document.getElementById('movHead');
        const body = document.getElementById('movBody');
        const summary = document.getElementById('movementsSummary');
        if (!head || !body || !summary) return; // tab not in DOM yet

        const view = document.getElementById('movView')?.value || 'detailed';
        const rows = getAllMovementsFiltered();

        if (view === 'daily') {
            head.innerHTML = `<tr>
                <th>Date</th><th>Movements (count)</th><th>Total Qty (sum)</th>
            </tr>`;
            const byDay = {};
            rows.forEach(r => {
                const d = r.date || 'NO-DATE';
                byDay[d] = byDay[d] || { date: d, count: 0, total: 0 };
                byDay[d].count += 1;
                byDay[d].total += Number(r.qty||0);
            });
            const days = Object.values(byDay).sort((a,b)=>a.date.localeCompare(b.date));
            body.innerHTML = days.map(d => `<tr>
                <td>${d.date}</td><td>${d.count}</td><td>${d.total}</td>
            </tr>`).join('');
            summary.innerHTML = `<b>Total records:</b> ${rows.length} &nbsp; | &nbsp; <b>Days:</b> ${days.length}`;
        } else {
            head.innerHTML = `<tr>
                <th>Date</th><th>Produto</th><th>Separador</th><th>Tipo</th><th>Qty</th><th>By</th><th>Nota</th><th>A√ß√µes</th>
            </tr>`;
            body.innerHTML = rows.map(r => `<tr>
                <td>${r.date || ''}</td>
                <td>${r.produto || ''}</td>
                <td>${r.tab || ''}</td>
                <td>${r.tipo || ''}</td>
                <td>${r.qty ?? ''}</td>
                <td>${(r.by || '').toString()}</td>
                <td>${(r.note || '').toString()}</td>
                <td><button class="mini" onclick="deleteMovementByKey('${r._key || ''}')">üóëÔ∏è</button></td>
            </tr>`).join('');
            summary.innerHTML = `<b>Total records:</b> ${rows.length}`;
        }
    }

    function exportMovementsCSV() {
        const rows = getAllMovementsFiltered();
        if (!rows.length) return alert('No movements to export for this filter.');
        const headers = ['month','date','produto','tab','tipo','qty','by','note'];
        downloadCSV(headers, rows, `movements_${currentMonth}.csv`);
    }

    function exportMovementsXLSX() {
        const rows = getAllMovementsFiltered();
        if (!rows.length) return alert('No movements to export for this filter.');
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(rows), "Movements");
        XLSX.writeFile(wb, `movements_${currentMonth}.xlsx`);
    }

  function __officeMovementsOnly(){
    const rows = getAllMovementsBase();
    return rows.filter(r => String(r.uid||"") === "office-sync");
  }

  function exportOfficeMovementsCSV(){
    const rows = __officeMovementsOnly();
    const headers = Object.keys(rows[0] || {date:"", sku:"", type:"", qty:"", sourceId:"", by:"", uid:""});
    downloadCSV(headers, rows, `office_movements_${currentMonth}_${new Date().toISOString().slice(0,10)}.csv`);
  }

  function exportOfficeMovementsXLSX(){
    const rows = __officeMovementsOnly();
    exportXLSX(rows, `office_movements_${currentMonth}_${new Date().toISOString().slice(0,10)}.xlsx`);
  }


function exportWarehouseCSV() {
        if (!warehouseItems.length) { alert('No warehouse data to export.'); return; }
        const headers = ['produto','posicao','dimensoes','peso','volume'];
        const rows = warehouseItems.map(r => ({
            produto: r.produto || '',
            posicao: r.posicao || '',
            dimensoes: r.dimensoes || '',
            peso: r.peso || '',
            volume: r.volume || ''
        }));
        downloadCSV(headers, rows, `warehouse_master_${new Date().toISOString().slice(0,10)}.csv`);
    }


  // Expose module functions for inline onclick handlers
  window.__startOfficeSyncImpl = startOfficeSync;
  window.exportOfficeMovementsCSV = exportOfficeMovementsCSV;
  window.exportOfficeMovementsXLSX = exportOfficeMovementsXLSX;

</script>
</body>
</html>
